<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Credential Service Manager</title>
    <style>
        :root {
            --primary-color: #6366f1;
            --primary-dark: #4f46e5;
            --success-color: #10b981;
            --danger-color: #ef4444;
            --warning-color: #f59e0b;
            --gray-50: #f9fafb;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-400: #9ca3af;
            --gray-500: #6b7280;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --gray-900: #111827;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: var(--gray-800);
            line-height: 1.5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 3rem;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }


        .input-group {
            display: flex;
            gap: 1rem;
            align-items: end;
        }

        .input-group label {
            flex: 1;
            font-weight: 500;
            color: var(--gray-600);
        }

        .input-group input {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--gray-200);
            border-radius: 0.5rem;
            font-size: 1rem;
            margin-top: 0.5rem;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn-success {
            background-color: var(--success-color);
            color: white;
        }

        .btn-danger {
            background-color: var(--danger-color);
            color: white;
        }

        .btn-warning {
            background-color: var(--warning-color);
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .connection-status {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .status-connected {
            background-color: rgba(16, 185, 129, 0.1);
            color: var(--success-color);
        }

        .status-disconnected {
            background-color: rgba(239, 68, 68, 0.1);
            color: var(--danger-color);
        }

        .modules-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1.5rem;
        }

        .module-card {
            background: white;
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .module-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
        }

        .module-header {
            padding: 1.5rem;
            background: linear-gradient(135deg, var(--gray-50) 0%, var(--gray-100) 100%);
            border-bottom: 1px solid var(--gray-200);
        }

        .module-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--gray-800);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .module-icon {
            width: 2rem;
            height: 2rem;
            border-radius: 0.5rem;
            background: var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .module-status {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.875rem;
        }

        .status-dot {
            width: 0.5rem;
            height: 0.5rem;
            border-radius: 50%;
        }

        .status-enabled { background-color: var(--success-color); }
        .status-disabled { background-color: var(--gray-400); }

        .module-content {
            padding: 1.5rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            font-weight: 500;
            color: var(--gray-700);
            margin-bottom: 0.5rem;
        }

        .form-group input, .form-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--gray-200);
            border-radius: 0.5rem;
            font-size: 0.9rem;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .form-group input[type="password"] {
            font-family: 'Courier New', monospace;
        }

        .module-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .module-actions .btn {
            font-size: 0.875rem;
            padding: 0.5rem 1rem;
        }

        .validation-result {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: 0.5rem;
            font-size: 0.9rem;
        }

        .validation-success {
            background-color: rgba(16, 185, 129, 0.1);
            color: var(--success-color);
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .validation-error {
            background-color: rgba(239, 68, 68, 0.1);
            color: var(--danger-color);
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .collapsible-details {
            margin-top: 0.5rem;
        }

        .collapsible-toggle {
            background: none;
            border: none;
            color: var(--primary-color);
            cursor: pointer;
            font-size: 0.875rem;
            text-decoration: underline;
        }

        .collapsible-content {
            margin-top: 0.5rem;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .loading {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .spinner {
            width: 1rem;
            height: 1rem;
            border: 2px solid var(--gray-200);
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* QR Code Modal Styles */
        .qr-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .qr-modal .modal-content {
            background: white;
            border-radius: 1rem;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .qr-modal .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--gray-200);
        }
        
        .qr-modal .modal-header h3 {
            margin: 0;
            color: var(--gray-800);
        }
        
        .qr-modal .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--gray-500);
            padding: 0.25rem;
            border-radius: 0.25rem;
        }
        
        .qr-modal .modal-close:hover {
            background: var(--gray-100);
            color: var(--gray-700);
        }
        
        .qr-container {
            text-align: center;
        }
        
        .qr-container #qrCode {
            margin: 1rem 0;
            display: flex;
            justify-content: center;
        }
        
        .qr-info {
            margin-top: 1.5rem;
        }
        
        .qr-url {
            background: var(--gray-100);
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-family: monospace;
            font-size: 0.9rem;
            word-break: break-all;
            margin: 1rem 0;
        }
        
        .qr-instructions {
            color: var(--gray-600);
            font-size: 0.9rem;
            line-height: 1.6;
            margin-top: 1rem;
        }

        .toast {
            position: fixed;
            top: 2rem;
            right: 2rem;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            color: white;
            font-weight: 500;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast-success { background-color: var(--success-color); }
        .toast-error { background-color: var(--danger-color); }
        .toast-warning { background-color: var(--warning-color); }

        .statistics {
            background: white;
            border-radius: 1rem;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .health-check-section {
            background: white;
            border-radius: 1rem;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .health-check-section h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--gray-700);
        }

        .health-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .health-results {
            background: var(--gray-50);
            border-radius: 0.5rem;
            padding: 1rem;
            min-height: 200px;
        }

        .health-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: white;
            border-radius: 0.5rem;
            border-left: 4px solid var(--gray-300);
        }

        .health-item.healthy {
            border-left-color: var(--success-color);
        }

        .health-item.warning {
            border-left-color: var(--warning-color);
        }

        .health-item.error {
            border-left-color: var(--danger-color);
        }

        .health-item-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .health-status {
            font-weight: 600;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.875rem;
        }

        .health-status.healthy {
            background: var(--success-color);
            color: white;
        }

        .health-status.warning {
            background: var(--warning-color);
            color: white;
        }

        .health-status.info {
            background: var(--gray-400);
            color: white;
        }

        .health-status.error {
            background: var(--danger-color);
            color: white;
        }

        .nodered-section {
            background: white;
            border-radius: 1rem;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .nodered-section h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--gray-700);
        }

        .nodered-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .nodered-results {
            background: var(--gray-50);
            border-radius: 0.5rem;
            padding: 1rem;
            min-height: 200px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 2rem;
            border-radius: 1rem;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close {
            color: var(--gray-400);
            float: right;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: var(--gray-600);
        }

        .upload-area {
            border: 2px dashed var(--gray-300);
            border-radius: 0.5rem;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .upload-area:hover {
            border-color: var(--primary-color);
        }

        .upload-area.dragover {
            border-color: var(--primary-color);
            background-color: var(--primary-color);
            color: white;
        }

        .upload-preview {
            margin-top: 1rem;
            padding: 1rem;
            background: var(--gray-50);
            border-radius: 0.5rem;
        }

        .upload-preview pre {
            background: white;
            padding: 1rem;
            border-radius: 0.25rem;
            overflow-x: auto;
            max-height: 300px;
            font-size: 0.875rem;
        }

        .backup-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .backup-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .backup-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            margin-bottom: 0.5rem;
            background: white;
            border-radius: 0.5rem;
            border: 1px solid var(--gray-200);
        }

        .backup-info {
            flex: 1;
        }

        .backup-actions {
            display: flex;
            gap: 0.5rem;
        }

        .backup-item h4 {
            margin: 0 0 0.25rem 0;
            color: var(--gray-700);
        }

        .backup-item p {
            margin: 0;
            font-size: 0.875rem;
            color: var(--gray-600);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
        }

        .stat-card {
            text-align: center;
            padding: 1rem;
            border-radius: 0.5rem;
            background: var(--gray-50);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .stat-label {
            font-size: 0.875rem;
            color: var(--gray-600);
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .modules-grid {
                grid-template-columns: 1fr;
            }
            
            .input-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .module-actions {
                justify-content: center;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .hidden {
            display: none !important;
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Telegram Messaging Styles */
        .telegram-messaging {
            background: white;
            border-radius: 1rem;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .messaging-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--gray-200);
        }

        .messaging-header h2 {
            font-size: 1.5rem;
            color: var(--gray-700);
        }

        .messaging-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .messaging-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
            border-bottom: 1px solid var(--gray-200);
        }

        .tab-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            background: none;
            color: var(--gray-600);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
            font-weight: 500;
        }

        .tab-btn:hover {
            color: var(--primary-color);
        }

        .tab-btn.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .messages-container {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid var(--gray-200);
            border-radius: 0.5rem;
            padding: 1rem;
        }

        .message-item {
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 0.5rem;
            background: var(--gray-50);
            border-left: 4px solid var(--primary-color);
            overflow: visible !important;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .message-from {
            font-weight: 600;
            color: var(--gray-700);
        }

        .message-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .message-time {
            font-size: 0.8rem;
            color: var(--gray-500);
        }

        .message-media {
            margin-top: 0.5rem;
            overflow: visible !important;
        }

        .media-item {
            margin: 0.5rem 0;
            border-radius: 0.5rem;
            overflow: hidden;
            background: var(--gray-100);
        }

        .media-image {
            width: 100%;
            max-width: 300px;
            height: auto;
            cursor: pointer;
            border-radius: 0.5rem;
            transition: transform 0.2s ease;
        }

        .media-image:hover {
            transform: scale(1.02);
        }

        .media-video {
            width: 100%;
            max-width: 400px;
            height: auto;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        
        .media-video:hover {
            transform: scale(1.02);
        }
        
        .media-video-note {
            border-radius: 50% !important;
            width: 240px !important;
            height: 240px !important;
            object-fit: cover;
            cursor: pointer;
        }
        
        .media-video-note:hover {
            transform: scale(1.05);
        }

        .media-audio {
            width: 100%;
            max-width: 300px;
        }

        .media-document {
            padding: 1rem;
            background: var(--primary-color);
            color: white;
            border-radius: 0.5rem;
            cursor: pointer;
            text-align: center;
            transition: background-color 0.2s ease;
        }

        .media-document:hover {
            background: var(--primary-dark);
        }

        .media-info {
            font-size: 0.8rem;
            color: var(--gray-600);
            margin-top: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        /* Voice message styles */
        .voice-container {
            width: 100%;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            margin: 0.5rem 0;
            position: relative;
            overflow: visible !important;
        }

        .voice-player-section {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .voice-meta {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }

        .voice-info {
            font-size: 0.85rem;
            color: var(--gray-600);
        }

        .transcribe-btn {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            font-weight: 500;
        }

        .transcribe-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .transcribe-btn:disabled {
            background: var(--gray-400);
            cursor: not-allowed;
            transform: none;
        }

        .transcription-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 2px solid #007bff;
            display: none !important;
            background: #fffacd !important;
        }

        .transcription-section.show {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            height: auto !important;
            min-height: 100px !important;
        }

        .transcription-header {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--gray-700);
            margin-bottom: 0.5rem;
        }

        .transcription-body {
            background: white;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #dee2e6;
            min-height: 60px;
        }

        .transcription-text-content {
            font-size: 1rem;
            line-height: 1.6;
            color: #212529;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .transcription-loading {
            color: var(--gray-600);
            font-style: italic;
            text-align: center;
            padding: 1rem;
        }

        .transcription-error {
            color: var(--danger-color);
            padding: 1rem;
            text-align: center;
        }

        .transcription-meta {
            font-size: 0.75rem;
            color: var(--gray-500);
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid #e9ecef;
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
        }

        /* Media modal styles */
        .media-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            position: relative;
            max-width: 90%;
            max-height: 90%;
            background: white;
            border-radius: 0.5rem;
            overflow: hidden;
        }

        .modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 2rem;
            color: white;
            cursor: pointer;
            z-index: 1001;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: rgba(0, 0, 0, 0.7);
        }

        .modal-image {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }

        .photo-selector {
            position: absolute;
            top: 60px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 1002;
        }

        .photo-selector label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .photo-selector select {
            background: white;
            color: black;
            border: none;
            padding: 5px;
            border-radius: 3px;
            font-size: 0.9rem;
        }

        .image-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.9rem;
            z-index: 1002;
        }

        /* API documentation styles */
        .api-documentation {
            padding: 1rem;
        }

        .api-section {
            margin-bottom: 2rem;
        }

        .api-section h3 {
            color: var(--primary-color);
            margin-bottom: 1rem;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }

        .api-section h4 {
            color: var(--gray-700);
            margin-bottom: 1rem;
            margin-top: 1.5rem;
        }

        .api-endpoint {
            background: var(--gray-50);
            border: 1px solid var(--gray-200);
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        .endpoint-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: var(--gray-100);
            border-bottom: 1px solid var(--gray-200);
        }

        .method {
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-weight: bold;
            font-size: 0.8rem;
            min-width: 60px;
            text-align: center;
        }

        .method.get {
            background: var(--success-color);
            color: white;
        }

        .method.post {
            background: var(--warning-color);
            color: white;
        }

        .method.delete {
            background: var(--danger-color);
            color: white;
        }

        .method.put {
            background: var(--info-color);
            color: white;
        }

        .url {
            font-family: 'Courier New', monospace;
            background: var(--gray-200);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            flex: 1;
        }

        .endpoint-description {
            padding: 1rem;
            color: var(--gray-600);
            font-style: italic;
        }

        .endpoint-example {
            padding: 1rem;
            background: var(--gray-900);
            color: var(--gray-100);
        }

        .endpoint-example pre {
            margin: 0;
            overflow-x: auto;
        }

        .endpoint-example code {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .api-test-results {
            background: var(--gray-50);
            border: 1px solid var(--gray-200);
            border-radius: 0.5rem;
            padding: 1rem;
            min-height: 100px;
        }

        .test-result {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 0.25rem;
            border-left: 4px solid;
        }

        .test-result.success {
            background: #f0f9ff;
            border-left-color: var(--success-color);
            color: var(--success-color);
        }

        .test-result.error {
            background: #fef2f2;
            border-left-color: var(--danger-color);
            color: var(--danger-color);
        }

        .test-result.info {
            background: #f0f9ff;
            border-left-color: var(--info-color);
            color: var(--info-color);
        }

        .test-result pre {
            background: var(--gray-100);
            padding: 0.5rem;
            border-radius: 0.25rem;
            margin-top: 0.5rem;
            overflow-x: auto;
            font-size: 0.8rem;
        }

        .message-content {
            margin-bottom: 0.5rem;
        }

        .message-type {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            background: var(--primary-color);
            color: white;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            margin-right: 0.5rem;
        }

        .message-text {
            color: var(--gray-800);
        }

        .message-media {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: white;
            border-radius: 0.25rem;
            border: 1px solid var(--gray-200);
            overflow: visible !important;
        }

        .media-info {
            font-size: 0.8rem;
            color: var(--gray-600);
        }

        .send-message-form {
            max-width: 600px;
        }

        .webhook-settings {
            max-width: 600px;
        }

        .webhook-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .webhook-status {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: 0.5rem;
            font-size: 0.9rem;
        }

        .webhook-status.success {
            background-color: rgba(16, 185, 129, 0.1);
            color: var(--success-color);
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .webhook-status.error {
            background-color: rgba(239, 68, 68, 0.1);
            color: var(--danger-color);
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .webhook-status.info {
            background-color: rgba(99, 102, 241, 0.1);
            color: var(--primary-color);
            border: 1px solid rgba(99, 102, 241, 0.2);
        }

        .polling-status {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            margin-left: 1rem;
            font-size: 0.9rem;
            font-weight: 500;
            border: 2px solid;
            transition: all 0.3s ease;
        }

        .polling-active {
            background-color: rgba(16, 185, 129, 0.1);
            border-color: var(--success-color);
            color: var(--success-color);
            animation: pulse-success 2s infinite;
        }
        
        .polling-inactive {
            background-color: rgba(239, 68, 68, 0.1);
            border-color: var(--danger-color);
            color: var(--danger-color);
        }
        
        .status-detail {
            font-size: 0.8rem;
            opacity: 0.8;
            font-weight: 400;
        }
        
        @keyframes pulse-success {
            0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(16, 185, 129, 0); }
            100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
        }


        .polling-inactive {
            background-color: rgba(239, 68, 68, 0.1);
            color: var(--danger-color);
        }

        .messaging-stats {
            display: flex;
            gap: 2rem;
            margin-bottom: 1rem;
            padding: 1rem;
            background: var(--gray-50);
            border-radius: 0.5rem;
            border: 1px solid var(--gray-200);
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-item .stat-label {
            font-size: 0.8rem;
            color: var(--gray-600);
            margin-bottom: 0.25rem;
        }

        .stat-item .stat-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--primary-color);
        }

        @media (max-width: 768px) {
            .messaging-header {
                flex-direction: column;
                align-items: stretch;
                gap: 1rem;
            }

            .messaging-controls {
                justify-content: center;
            }

            .messaging-tabs {
                flex-wrap: wrap;
            }

            .tab-btn {
                flex: 1;
                min-width: 120px;
            }

            .webhook-actions {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>🔐 Credential Service Manager</h1>
            <p>Unified management and validation of your API credentials</p>
            <div style="display: flex; justify-content: center; align-items: center; gap: 1rem; margin-top: 1rem;">
                <div class="connection-status" id="connectionStatus">
                    <span class="status-dot"></span>
                    <span>Checking connection...</span>
                </div>
                <button class="btn btn-primary" onclick="showApiDocumentation()" style="background: rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 255, 255, 0.3);">
                    📚 API Documentation
                </button>
                <button class="btn btn-primary" onclick="showQRCode()" style="background: rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 255, 255, 0.3);">
                    📱 QR Code
                </button>
            </div>
        </div>


        <!-- Statistics -->
        <div class="statistics hidden" id="statistics">
            <h2>📊 System Statistics</h2>
            <div class="stats-grid" id="statsGrid">
                <!-- Dynamically generated -->
            </div>
        </div>

        <!-- Health Check Section -->
        <div class="health-check-section">
            <h2>🏥 Health Check & Validation</h2>
            <div class="health-controls">
                <button class="btn btn-primary" onclick="runHealthCheck()">🔍 Run Health Check</button>
                <button class="btn btn-success" onclick="startPeriodicHealthCheck()">⏰ Start Periodic Check</button>
                <button class="btn btn-warning" onclick="stopPeriodicHealthCheck()">⏹️ Stop Periodic Check</button>
            </div>
            <div class="health-results" id="healthResults">
                <!-- Health check results will be displayed here -->
            </div>
        </div>

        <!-- Node-RED Management Section -->
        <div class="nodered-section">
            <h2>🔴 Node-RED Flow Management</h2>
            
            <!-- Node-RED Service Info -->
            <div class="nodered-info" id="noderedInfo" style="background: var(--gray-50); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem; border: 2px solid var(--gray-200);">
                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                    <strong style="color: var(--gray-700);">🌐 Service Address:</strong>
                    <span id="noderedServiceUrl" style="font-family: 'Courier New', monospace; color: var(--primary-color); font-weight: 500;">Loading...</span>
                    <button class="btn btn-sm" onclick="openNodeRedService()" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;">🔗 Open</button>
                </div>
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <strong style="color: var(--gray-700);">📊 Total Flows:</strong>
                    <span id="noderedFlowCount" style="font-weight: 600; color: var(--success-color);">-</span>
                </div>
            </div>
            
            <div class="nodered-controls">
                <button class="btn btn-primary" onclick="showFlowUpload()">📤 Upload Flow</button>
                <button class="btn btn-info" onclick="loadNodeRedFlows()">📋 Load Current Flows</button>
                <button class="btn btn-success" onclick="showBackupManager()">💾 Backup Manager</button>
                <button class="btn btn-warning" onclick="validateCurrentFlows()">✅ Validate Flows</button>
            </div>
            
            <!-- Flow Upload Modal -->
            <div class="modal" id="flowUploadModal">
                <div class="modal-content">
                    <span class="close" onclick="closeFlowUpload()">&times;</span>
                    <h3>📤 Upload Node-RED Flow</h3>
                    <div class="upload-area" id="uploadArea">
                        <p>📁 Drag & drop your flow JSON file here or click to select</p>
                        <input type="file" id="flowFileInput" accept=".json" style="display: none;">
                    </div>
                    <div class="upload-preview" id="uploadPreview" style="display: none;">
                        <h4>Flow Preview:</h4>
                        <pre id="flowPreview"></pre>
                        <button class="btn btn-primary" onclick="deployFlow()">🚀 Deploy Flow</button>
                    </div>
                </div>
            </div>

            <!-- Backup Manager Modal -->
            <div class="modal" id="backupModal">
                <div class="modal-content">
                    <span class="close" onclick="closeBackupManager()">&times;</span>
                    <h3>💾 Backup Manager</h3>
                    <div class="backup-controls">
                        <button class="btn btn-success" onclick="createBackup()">📦 Create Backup</button>
                        <button class="btn btn-info" onclick="refreshBackups()">🔄 Refresh</button>
                    </div>
                    <div class="backup-list" id="backupList">
                        <!-- Backup list will be populated here -->
                    </div>
                </div>
            </div>

            <div class="nodered-results" id="noderedResults">
                <!-- Node-RED operation results will be displayed here -->
            </div>
        </div>

        <!-- API Documentation Links -->
        <div class="api-documentation hidden" id="apiDocumentation">
            <div class="messaging-header">
                <h2>📚 API Documentation</h2>
                <p>Access detailed API documentation and testing tools for each service</p>
            </div>
            
            <div class="api-section">
                <h3>🔗 Service API Documentation</h3>
                <p>Click the buttons below to access complete API documentation for each service, including detailed endpoint descriptions, curl examples, and real-time testing features.</p>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin-top: 2rem;">
                    <a href="/telegram-api-docs.html" target="_blank" class="btn btn-primary" style="text-decoration: none; text-align: center; padding: 1.5rem; display: flex; flex-direction: column; align-items: center; gap: 0.5rem;">
                        <span style="font-size: 2rem;">📱</span>
                        <span style="font-weight: 600;">Telegram API Documentation</span>
                        <span style="font-size: 0.9rem; opacity: 0.8;">语音转文字, 快速回复, 消息管理</span>
                    </a>
                    
                    <a href="/home-assistant-api-docs.html" target="_blank" class="btn btn-warning" style="text-decoration: none; text-align: center; padding: 1.5rem; display: flex; flex-direction: column; align-items: center; gap: 0.5rem;">
                        <span style="font-size: 2rem;">🏠</span>
                        <span style="font-weight: 600;">Home Assistant API Documentation</span>
                        <span style="font-size: 0.9rem; opacity: 0.8;">Entity management, service calls, state control</span>
                    </a>
                    
                    <a href="/openai-api-docs.html" target="_blank" class="btn btn-success" style="text-decoration: none; text-align: center; padding: 1.5rem; display: flex; flex-direction: column; align-items: center; gap: 0.5rem;">
                        <span style="font-size: 2rem;">🤖</span>
                        <span style="font-weight: 600;">OpenAI API Documentation</span>
                        <span style="font-size: 0.9rem; opacity: 0.8;">AI chat, model management, intelligent conversation</span>
                    </a>
                    
                    <a href="/gemini-api-docs.html" target="_blank" class="btn btn-info" style="text-decoration: none; text-align: center; padding: 1.5rem; display: flex; flex-direction: column; align-items: center; gap: 0.5rem;">
                        <span style="font-size: 2rem;">💎</span>
                        <span style="font-weight: 600;">Google Gemini API Documentation</span>
                        <span style="font-size: 0.9rem; opacity: 0.8;">Multimodal AI, secure conversation, intelligent assistant</span>
                    </a>
                </div>
            </div>
            
            <div class="api-section">
                <h3>🔧 Basic API Information</h3>
                <p>Basic API endpoints provided by Credential Service:</p>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-top: 1rem;">
                    <div style="background: var(--gray-50); padding: 1rem; border-radius: 0.5rem; border: 1px solid var(--gray-200);">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <span style="background: var(--success-color); color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.8rem; font-weight: bold;">GET</span>
                            <span style="font-family: 'Courier New', monospace; font-size: 0.9rem;">/api/health</span>
                        </div>
                        <div style="font-size: 0.9rem; color: var(--gray-600);">Check service health status</div>
                    </div>
                    
                    <div style="background: var(--gray-50); padding: 1rem; border-radius: 0.5rem; border: 1px solid var(--gray-200);">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <span style="background: var(--success-color); color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.8rem; font-weight: bold;">GET</span>
                            <span style="font-family: 'Courier New', monospace; font-size: 0.9rem;">/api/modules</span>
                        </div>
                        <div style="font-size: 0.9rem; color: var(--gray-600);">Get all module list</div>
                    </div>
                    
                    <div style="background: var(--gray-50); padding: 1rem; border-radius: 0.5rem; border: 1px solid var(--gray-200);">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <span style="background: var(--success-color); color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.8rem; font-weight: bold;">GET</span>
                            <span style="font-family: 'Courier New', monospace; font-size: 0.9rem;">/api/statistics</span>
                        </div>
                        <div style="font-size: 0.9rem; color: var(--gray-600);">Get system statistics information</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Telegram Message Management -->
        <div class="telegram-messaging hidden" id="telegramMessaging">
            <div class="messaging-header">
                <h2>📱 Telegram Message Management</h2>
                <div class="messaging-controls">
                    <button class="btn btn-success" onclick="startTelegramPolling()">Start Polling</button>
                    <button class="btn btn-warning" onclick="stopTelegramPolling()">Stop Polling</button>
                    <button class="btn btn-primary" onclick="refreshMessages()">Refresh Messages</button>
                    <button class="btn btn-primary" onclick="reprocessMessages()">Reprocess</button>
                    <button class="btn btn-danger" onclick="clearMessages()">Clear History</button>
                </div>
            </div>
            
            <div class="messaging-stats" id="messagingStats">
                <div class="stat-item">
                    <span class="stat-label">Total Messages:</span>
                    <span class="stat-value" id="totalMessages">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Last Updated:</span>
                    <span class="stat-value" id="lastUpdate">-</span>
                </div>
            </div>
            
            <div class="messaging-tabs">
                <button class="tab-btn active" onclick="switchTab('messages')">Message History</button>
                <button class="tab-btn" onclick="switchTab('send')">Send Message</button>
                <button class="tab-btn" onclick="switchTab('webhook')">Webhook Settings</button>
                <button class="tab-btn" onclick="switchTab('api')">API Documentation</button>
            </div>
            
            <!-- Message History Tab -->
            <div class="tab-content active" id="tab-messages">
                <div class="messages-container">
                    <div class="messages-list" id="messagesList">
                        <!-- Message list will be dynamically generated here -->
                    </div>
                </div>
            </div>
            
            <!-- Send Message Tab -->
            <div class="tab-content" id="tab-send">
                <div class="send-message-form">
                    <div class="form-group">
                        <label for="sendChatId">Chat ID</label>
                        <input type="text" id="sendChatId" placeholder="Enter chat ID or username (e.g., @username or 123456789)">
                        <small style="color: var(--gray-500); font-size: 0.8rem;">
                            💡 Tip: You can click the "Reply" button in message history to auto-fill chat ID, or manually enter @username, user ID, or group ID
                        </small>
                    </div>
                    <div class="form-group">
                        <label for="sendMessageType">Message Type</label>
                        <select id="sendMessageType" onchange="updateSendForm()">
                            <option value="text">Text Message</option>
                            <option value="photo">Photo</option>
                            <option value="video">Video</option>
                            <option value="voice">Voice</option>
                            <option value="document">Document</option>
                        </select>
                    </div>
                    <div class="form-group" id="textMessageGroup">
                        <label for="sendText">Message Content</label>
                        <textarea id="sendText" rows="4" placeholder="Enter message content"></textarea>
                    </div>
                    <div class="form-group hidden" id="mediaMessageGroup">
                        <label for="sendMedia">Media File</label>
                        <input type="text" id="sendMedia" placeholder="Enter file ID or URL">
                    </div>
                    <div class="form-group">
                        <label for="sendCaption">Caption (Optional)</label>
                        <input type="text" id="sendCaption" placeholder="Enter caption">
                    </div>
                    <button class="btn btn-primary" onclick="sendTelegramMessage()">Send Message</button>
                </div>
            </div>
            
            <!-- Webhook Settings Tab -->
            <div class="tab-content" id="tab-webhook">
                <div class="webhook-settings">
                    <div class="form-group">
                        <label for="webhookUrl">Webhook URL</label>
                        <input type="url" id="webhookUrl" placeholder="https://your-domain.com/webhook">
                    </div>
                    <div class="form-group">
                        <label for="webhookSecret">Secret Token (Optional)</label>
                        <input type="text" id="webhookSecret" placeholder="Enter secret token">
                    </div>
                    <div class="webhook-actions">
                        <button class="btn btn-success" onclick="setWebhook()">Set Webhook</button>
                        <button class="btn btn-warning" onclick="removeWebhook()">Remove Webhook</button>
                        <button class="btn btn-primary" onclick="getWebhookInfo()">Get Info</button>
                    </div>
                    <div id="webhookStatus"></div>
                </div>
            </div>
            
            <!-- API Documentation Tab -->
            <div class="tab-content" id="tab-api">
                <div class="api-documentation">
                    <div class="api-section">
                        <h3>📚 API Documentation</h3>
                        <p>Below are all available API endpoints that you can copy and use directly or call in frontend applications.</p>
                    </div>
                    
                    <div class="api-section">
                        <h4>🔧 Basic Information</h4>
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method get">GET</span>
                                <span class="url">/api/health</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('GET', '/api/health')">Test</button>
                            </div>
                            <div class="endpoint-description">Check service health status</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X GET http://localhost:3000/api/health</code></pre>
                            </div>
                        </div>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method get">GET</span>
                                <span class="url">/api/modules</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('GET', '/api/modules')">Test</button>
                            </div>
                            <div class="endpoint-description">Get all module list</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X GET http://localhost:3000/api/modules</code></pre>
                            </div>
                        </div>
                    </div>
                    
                    <div class="api-section">
                        <h4>📱 Telegram Message Management</h4>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method get">GET</span>
                                <span class="url">/api/telegram/telegram/messages</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('GET', '/api/telegram/telegram/messages')">Test</button>
                            </div>
                            <div class="endpoint-description">Get message history</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X GET http://localhost:3000/api/telegram/telegram/messages</code></pre>
                            </div>
                        </div>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method post">POST</span>
                                <span class="url">/api/telegram/telegram/polling/start</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('POST', '/api/telegram/telegram/polling/start')">Test</button>
                            </div>
                            <div class="endpoint-description">Start message polling</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X POST http://localhost:3000/api/telegram/telegram/polling/start</code></pre>
                            </div>
                        </div>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method post">POST</span>
                                <span class="url">/api/telegram/telegram/polling/stop</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('POST', '/api/telegram/telegram/polling/stop')">Test</button>
                            </div>
                            <div class="endpoint-description">Stop message polling</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X POST http://localhost:3000/api/telegram/telegram/polling/stop</code></pre>
                            </div>
                        </div>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method post">POST</span>
                                <span class="url">/api/telegram/telegram/send/message</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('POST', '/api/telegram/telegram/send/message', {chat_id: '123456789', text: 'Hello World'})">Test</button>
                            </div>
                            <div class="endpoint-description">Send text message</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X POST http://localhost:3000/api/telegram/telegram/send/message \\
  -H "Content-Type: application/json" \\
  -d '{"chat_id": "123456789", "text": "Hello World"}'</code></pre>
                            </div>
                        </div>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method post">POST</span>
                                <span class="url">/api/telegram/telegram/send/photo</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('POST', '/api/telegram/telegram/send/photo', {chat_id: '123456789', photo: 'https://example.com/image.jpg', caption: 'Photo caption'})">Test</button>
                            </div>
                            <div class="endpoint-description">Send photo message</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X POST http://localhost:3000/api/telegram/telegram/send/photo \\
  -H "Content-Type: application/json" \\
  -d '{"chat_id": "123456789", "photo": "https://example.com/image.jpg", "caption": "Photo caption"}'</code></pre>
                            </div>
                        </div>
                    </div>
                    
                    <div class="api-section">
                        <h4>📁 File Operations</h4>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method get">GET</span>
                                <span class="url">/api/telegram/telegram/file-url/:fileId</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('GET', '/api/telegram/telegram/file-url/BAADBAADrwADBREAAYag8mS4AAH0Ag')">Test</button>
                            </div>
                            <div class="endpoint-description">Get file direct URL</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X GET http://localhost:3000/api/telegram/telegram/file-url/BAADBAADrwADBREAAYag8mS4AAH0Ag</code></pre>
                            </div>
                        </div>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method get">GET</span>
                                <span class="url">/api/telegram/telegram/file/:fileId</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('GET', '/api/telegram/telegram/file/BAADBAADrwADBREAAYag8mS4AAH0Ag')">Test</button>
                            </div>
                            <div class="endpoint-description">Get file information</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X GET http://localhost:3000/api/telegram/telegram/file/BAADBAADrwADBREAAYag8mS4AAH0Ag</code></pre>
                            </div>
                        </div>
                    </div>
                    
                    <div class="api-section">
                        <h4>🔗 Webhook Management</h4>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method post">POST</span>
                                <span class="url">/api/telegram/telegram/webhook/set</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('POST', '/api/telegram/telegram/webhook/set', {url: 'https://your-domain.com/webhook'})">Test</button>
                            </div>
                            <div class="endpoint-description">Set Webhook URL</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X POST http://localhost:3000/api/telegram/telegram/webhook/set \\
  -H "Content-Type: application/json" \\
  -d '{"url": "https://your-domain.com/webhook"}'</code></pre>
                            </div>
                        </div>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method delete">DELETE</span>
                                <span class="url">/api/telegram/telegram/webhook</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('DELETE', '/api/telegram/telegram/webhook')">Test</button>
                            </div>
                            <div class="endpoint-description">Delete Webhook</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X DELETE http://localhost:3000/api/telegram/telegram/webhook</code></pre>
                            </div>
                        </div>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method get">GET</span>
                                <span class="url">/api/telegram/telegram/webhook</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('GET', '/api/telegram/telegram/webhook')">Test</button>
                            </div>
                            <div class="endpoint-description">Get Webhook information</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X GET http://localhost:3000/api/telegram/telegram/webhook</code></pre>
                            </div>
                        </div>
                    </div>
                    
                    <div class="api-section">
                        <h4>🏠 Home Assistant API</h4>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method get">GET</span>
                                <span class="url">/api/home_assistant/home_assistant/states</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('GET', '/api/home_assistant/home_assistant/states')">Test</button>
                            </div>
                            <div class="endpoint-description">Get all entity states</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X GET http://localhost:3000/api/home_assistant/home_assistant/states</code></pre>
                            </div>
                        </div>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method get">GET</span>
                                <span class="url">/api/home_assistant/home_assistant/config</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('GET', '/api/home_assistant/home_assistant/config')">Test</button>
                            </div>
                            <div class="endpoint-description">Get Home Assistant configuration information</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X GET http://localhost:3000/api/home_assistant/home_assistant/config</code></pre>
                            </div>
                        </div>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method post">POST</span>
                                <span class="url">/api/home_assistant/home_assistant/test-connection</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('POST', '/api/home_assistant/home_assistant/test-connection')">Test</button>
                            </div>
                            <div class="endpoint-description">Test Home Assistant connection</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X POST http://localhost:3000/api/home_assistant/home_assistant/test-connection</code></pre>
                            </div>
                        </div>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method get">GET</span>
                                <span class="url">/api/home_assistant/home_assistant/entities</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('GET', '/api/home_assistant/home_assistant/entities')">Test</button>
                            </div>
                            <div class="endpoint-description">Get all entity list</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X GET http://localhost:3000/api/home_assistant/home_assistant/entities</code></pre>
                            </div>
                        </div>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method get">GET</span>
                                <span class="url">/api/home_assistant/home_assistant/entity/:entityId</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('GET', '/api/home_assistant/home_assistant/entity/light.living_room')">Test</button>
                            </div>
                            <div class="endpoint-description">Get specific entity information</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X GET http://localhost:3000/api/home_assistant/home_assistant/entity/light.living_room</code></pre>
                            </div>
                        </div>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method post">POST</span>
                                <span class="url">/api/home_assistant/home_assistant/call-service</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('POST', '/api/home_assistant/home_assistant/call-service', {domain: 'light', service: 'turn_on', entity_id: 'light.living_room'})">Test</button>
                            </div>
                            <div class="endpoint-description">Call Home Assistant service</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X POST http://localhost:3000/api/home_assistant/home_assistant/call-service \\
  -H "Content-Type: application/json" \\
  -d '{"domain": "light", "service": "turn_on", "entity_id": "light.living_room"}'</code></pre>
                            </div>
                        </div>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method post">POST</span>
                                <span class="url">/api/home_assistant/home_assistant/entity/:entityId/turn_on</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('POST', '/api/home_assistant/home_assistant/entity/light.living_room/turn_on')">Test</button>
                            </div>
                            <div class="endpoint-description">Turn on entity</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X POST http://localhost:3000/api/home_assistant/home_assistant/entity/light.living_room/turn_on</code></pre>
                            </div>
                        </div>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method post">POST</span>
                                <span class="url">/api/home_assistant/home_assistant/entity/:entityId/turn_off</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('POST', '/api/home_assistant/home_assistant/entity/light.living_room/turn_off')">Test</button>
                            </div>
                            <div class="endpoint-description">Turn off entity</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X POST http://localhost:3000/api/home_assistant/home_assistant/entity/light.living_room/turn_off</code></pre>
                            </div>
                        </div>
                        
                        <div class="api-endpoint">
                            <div class="endpoint-header">
                                <span class="method post">POST</span>
                                <span class="url">/api/home_assistant/home_assistant/entity/:entityId/set_state</span>
                                <button class="btn btn-sm btn-primary" onclick="testApi('POST', '/api/home_assistant/home_assistant/entity/light.living_room/set_state', {state: 'on', attributes: {brightness: 255}})"">Test</button>
                            </div>
                            <div class="endpoint-description">Set entity state</div>
                            <div class="endpoint-example">
                                <pre><code>curl -X POST http://localhost:3000/api/home_assistant/home_assistant/entity/light.living_room/set_state \\
  -H "Content-Type: application/json" \\
  -d '{"state": "on", "attributes": {"brightness": 255}}'</code></pre>
                            </div>
                        </div>
                    </div>
                    
                    <div class="api-section">
                        <h4>🧪 API Test Results</h4>
                        <div id="apiTestResults" class="api-test-results">
                            <p>Click the "Test" buttons above to test API endpoints</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Module Management -->
        <div class="modules-grid" id="modulesGrid">
            <!-- Dynamically generated module cards -->
        </div>
    </div>

    <!-- QR Code Modal -->
    <div class="qr-modal hidden" id="qrModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>📱 Mobile Access QR Code</h3>
                <button class="modal-close" onclick="closeQRCode()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="qr-container">
                    <div id="qrCode"></div>
                    <div class="qr-info">
                        <p><strong>Scan with your phone to access:</strong></p>
                        <p id="qrUrl" class="qr-url"></p>
                        <p class="qr-instructions">
                            📱 Open your phone's camera or QR code scanner<br>
                            📷 Point it at the QR code above<br>
                            🔗 Tap the notification to open the page
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notifications -->
    <div class="toast" id="toast">
        <span id="toastMessage"></span>
    </div>

    <!-- QR Code Library - Using QR.js -->
    <script src="https://cdn.jsdelivr.net/npm/qrjs@0.1.2/qr.min.js"></script>

    <script>
        // Global state
        let modules = {};
        let isConnected = false;
        let telegramPollingStatus = false;
        let healthCheckInterval = null;
        let currentFlowData = null;

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Directly show statistics without API key requirement
            document.getElementById('statistics').classList.remove('hidden');
            checkConnection();
            loadModules();
            loadStatistics();
            loadNodeRedInfo(); // Load Node-RED service info
            setInterval(refreshData, 30000); // Refresh data every 30 seconds
            
            // If Telegram module is available, set up automatic message refresh
            setInterval(() => {
                if (modules.telegram && modules.telegram.data && modules.telegram.data.messaging && modules.telegram.data.messaging.isPolling) {
                    refreshMessages();
                }
            }, 5000); // Refresh messages every 5 seconds
        });


        // Check connection status
        async function checkConnection() {
            try {
                const response = await fetch('/api/health');
                
                const data = await response.json();
                isConnected = response.ok;
                
                updateConnectionStatus(isConnected);
                
                if (isConnected) {
                    showToast('✅ Connected successfully!', 'success');
                    document.getElementById('statistics').classList.remove('hidden');
                    loadModules();
                    loadStatistics();
                } else {
                    showToast('❌ Connection failed', 'error');
                    document.getElementById('statistics').classList.add('hidden');
                    document.getElementById('telegramMessaging').classList.add('hidden');
                }
            } catch (error) {
                console.error('Connection check failed:', error);
                showToast('❌ Connection failed: Network error', 'error');
                updateConnectionStatus(false);
            }
        }

        // Update connection status display
        function updateConnectionStatus(connected) {
            const statusEl = document.getElementById('connectionStatus');
            const dot = statusEl.querySelector('.status-dot');
            const text = statusEl.querySelector('span:last-child');
            
            if (connected) {
                statusEl.className = 'connection-status status-connected';
                dot.className = 'status-dot status-enabled';
                text.textContent = 'Connected';
            } else {
                statusEl.className = 'connection-status status-disconnected';
                dot.className = 'status-dot status-disabled';
                text.textContent = 'Disconnected';
            }
        }

        // API Key (可选，用于需要认证的API)
        const apiKey = '';

        // Load module list
        async function loadModules() {
            if (!isConnected) return;
            
            try {
                const response = await fetch('/api/modules');
                
                if (response.ok) {
                    const data = await response.json();
                    modules = data.data;
                    renderModules();
                } else {
                    showToast('Failed to load modules', 'error');
                }
            } catch (error) {
                console.error('Failed to load modules:', error);
                showToast('Failed to load modules', 'error');
            }
        }

        // Load statistics
        async function loadStatistics() {
            if (!isConnected) return;
            
            try {
                const response = await fetch('/api/statistics');
                
                if (response.ok) {
                    const data = await response.json();
                    renderStatistics(data.data);
                }
            } catch (error) {
                console.error('Failed to load statistics:', error);
            }
        }

        // Render statistics
        function renderStatistics(stats) {
            const grid = document.getElementById('statsGrid');
            grid.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${stats.totalModules}</div>
                    <div class="stat-label">Total Modules</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stats.enabledModules}</div>
                    <div class="stat-label">Enabled</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stats.initializedModules}</div>
                    <div class="stat-label">Initialized</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stats.disabledModules}</div>
                    <div class="stat-label">Disabled</div>
                </div>
            `;
        }

        // Render module cards
        function renderModules() {
            const grid = document.getElementById('modulesGrid');
            grid.innerHTML = '';
            
            Object.entries(modules).forEach(([name, moduleData]) => {
                // Skip agent module - it's not displayed in the UI
                if (name === 'agent') return;
                
                const data = moduleData.data || {};
                const card = createModuleCard(name, data);
                grid.appendChild(card);
            });
            
            // Check Telegram module after rendering
            setTimeout(() => {
                checkTelegramModule();
            }, 100);
        }

        // Create module card
        function createModuleCard(name, data) {
            const card = document.createElement('div');
            card.className = 'module-card fade-in';
            card.id = `module-${name}`;
            
            const iconLetter = name.charAt(0).toUpperCase();
            const isEnabled = data.enabled || false;
            const isInitialized = data.initialized || false;
            
            card.innerHTML = `
                <div class="module-header">
                    <div class="module-title">
                        <div class="module-icon">${iconLetter}</div>
                        ${capitalizeFirst(name)}
                    </div>
                    <div class="module-status">
                        <div class="status-indicator">
                            <span class="status-dot ${isEnabled ? 'status-enabled' : 'status-disabled'}"></span>
                            <span>${isEnabled ? 'Enabled' : 'Disabled'}</span>
                        </div>
                        <div class="status-indicator">
                            <span>Initialized: ${isInitialized ? '✓' : '✗'}</span>
                        </div>
                    </div>
                </div>
                <div class="module-content">
                    <div id="credentials-${name}">
                        <!-- Credential form will be dynamically generated here -->
                    </div>
                    ${name === 'nodered' ? `
                    <div id="nodered-flows-list" style="margin-top: 1rem; padding: 1rem; background: var(--gray-50); border-radius: 0.5rem; border: 1px solid var(--gray-200);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                            <h4 style="margin: 0; color: var(--gray-700);">📋 Running Flows</h4>
                            <button class="btn btn-sm btn-info" onclick="loadNodeRedFlowsForCard()" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;">🔄 Refresh</button>
                        </div>
                        <div id="nodered-flows-content" style="font-size: 0.9rem; color: var(--gray-600);">
                            Loading flows...
                        </div>
                    </div>
                    ` : ''}
                    <div class="module-actions">
                        <button class="btn ${isEnabled ? 'btn-warning' : 'btn-success'}" 
                                onclick="toggleModule('${name}', ${!isEnabled})">
                            ${isEnabled ? 'Disable' : 'Enable'}
                        </button>
                        <button class="btn btn-primary" onclick="validateModule('${name}')">Validate</button>
                        <button class="btn btn-primary" onclick="testConnection('${name}')">Test Connection</button>
                        <button class="btn btn-warning" onclick="reloadModule('${name}')">Reload</button>
                        <button class="btn btn-danger" onclick="clearCache('${name}')">Clear Cache</button>
                        ${name === 'telegram' ? '<button class="btn btn-success" onclick="showTelegramMessaging()">Message Management</button>' : ''}
                    </div>
                    <div id="result-${name}"></div>
                </div>
            `;
            
            // Load credential form
            loadCredentialForm(name);
            
            // For Node-RED, also load flows list
            if (name === 'nodered') {
                setTimeout(() => loadNodeRedFlowsForCard(), 500);
            }
            
            return card;
        }

        // Load credential form
        async function loadCredentialForm(moduleName) {
            try {
                // Get schema
                const schemaResponse = await fetch(`/api/schema/${moduleName}`, {
                });
                
                if (!schemaResponse.ok) return;
                
                const schemaData = await schemaResponse.json();
                const schema = schemaData.data;
                
                // Get existing credentials
                const credsResponse = await fetch(`/api/credentials/${moduleName}`, {
                });
                
                const existingCreds = credsResponse.ok ? (await credsResponse.json()).data : {};
                
                // Generate form
                const formContainer = document.getElementById(`credentials-${moduleName}`);
                formContainer.innerHTML = generateCredentialForm(moduleName, schema, existingCreds);
                
            } catch (error) {
                console.error(`Failed to load credential form for ${moduleName}:`, error);
            }
        }

        // Generate credential form
        function generateCredentialForm(moduleName, schema, existingCreds) {
            if (!schema.properties) return '<p>No credential configuration</p>';
            
            let formHTML = '';
            
            Object.entries(schema.properties).forEach(([field, definition]) => {
                const value = existingCreds[field] || '';
                const inputType = definition.sensitive ? 'password' : 
                                 definition.ui?.widget === 'url' ? 'url' : 'text';
                const placeholder = definition.ui?.placeholder || definition.example || '';
                const help = definition.ui?.help || definition.description || '';
                
                formHTML += `
                    <div class="form-group">
                        <label for="${moduleName}-${field}">
                            ${definition.title || capitalizeFirst(field)}
                            ${definition.required ? '*' : ''}
                        </label>
                        <input type="${inputType}" 
                               id="${moduleName}-${field}" 
                               name="${field}"
                               value="${value}" 
                               placeholder="${placeholder}"
                               ${definition.required ? 'required' : ''}
                               title="${help}">
                        ${help ? `<small style="color: var(--gray-500); font-size: 0.8rem;">${help}</small>` : ''}
                    </div>
                `;
            });
            
            formHTML += `
                <button type="button" class="btn btn-primary" onclick="saveCredentials('${moduleName}')">
                    Save Credentials
                </button>
            `;
            
            return formHTML;
        }

        // Save credentials
        async function saveCredentials(moduleName) {
            const formContainer = document.getElementById(`credentials-${moduleName}`);
            const inputs = formContainer.querySelectorAll('input[name]');
            const credentials = {};
            
            inputs.forEach(input => {
                credentials[input.name] = input.value;
            });
            
            try {
                const response = await fetch(`/api/credentials/${moduleName}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(credentials)
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showToast(`${capitalizeFirst(moduleName)} credentials saved`, 'success');
                } else {
                    showToast(`Save failed: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('Failed to save credentials:', error);
                showToast('Save failed', 'error');
            }
        }

        // Toggle module status
        async function toggleModule(moduleName, enabled) {
            try {
                const response = await fetch(`/api/modules/${moduleName}/enabled`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ enabled })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showToast(`${capitalizeFirst(moduleName)} ${enabled ? 'enabled' : 'disabled'}`, 'success');
                    loadModules(); // Refresh module status
                } else {
                    showToast(`Operation failed: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('Failed to toggle module:', error);
                showToast('Operation failed', 'error');
            }
        }

        // Validate module
        async function validateModule(moduleName) {
            const resultContainer = document.getElementById(`result-${moduleName}`);
            resultContainer.innerHTML = '<div class="loading"><div class="spinner"></div>Validating...</div>';
            
            try {
                console.log(`[Validate] Starting validation for ${moduleName}`);
                
                const response = await fetch(`/api/validate/${moduleName}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': apiKey
                    }
                });
                
                console.log(`[Validate] Response status: ${response.status} ${response.statusText}`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`[Validate] HTTP error: ${errorText}`);
                    displayValidationResult(moduleName, { 
                        success: false, 
                        error: `HTTP ${response.status}: ${response.statusText}` 
                    });
                    return;
                }
                
                const data = await response.json();
                console.log(`[Validate] Response data:`, data);
                displayValidationResult(moduleName, data);
                
            } catch (error) {
                console.error('[Validate] Exception:', error);
                displayValidationResult(moduleName, { 
                    success: false, 
                    error: `Validation error: ${error.message}` 
                });
            }
        }

        // Test connection
        async function testConnection(moduleName) {
            const resultContainer = document.getElementById(`result-${moduleName}`);
            resultContainer.innerHTML = '<div class="loading"><div class="spinner"></div>Testing connection...</div>';
            
            try {
                console.log(`[TestConnection] Starting test for ${moduleName}`);
                
                const response = await fetch(`/api/test-connection/${moduleName}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': apiKey
                    }
                });
                
                console.log(`[TestConnection] Response status: ${response.status} ${response.statusText}`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`[TestConnection] HTTP error: ${errorText}`);
                    displayValidationResult(moduleName, { 
                        success: false, 
                        error: `HTTP ${response.status}: ${response.statusText}` 
                    });
                    return;
                }
                
                const data = await response.json();
                console.log(`[TestConnection] Response data:`, data);
                displayValidationResult(moduleName, data);
                
            } catch (error) {
                console.error('[TestConnection] Exception:', error);
                displayValidationResult(moduleName, { 
                    success: false, 
                    error: `Test failed: ${error.message}` 
                });
            }
        }

        // Reload module
        async function reloadModule(moduleName) {
            try {
                const response = await fetch(`/api/modules/${moduleName}/reload`, {
                    method: 'POST',
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showToast(`${capitalizeFirst(moduleName)} module reloaded`, 'success');
                    loadModules();
                } else {
                    showToast(`Reload failed: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('Failed to reload module:', error);
                showToast('Reload failed', 'error');
            }
        }

        // Clear cache
        async function clearCache(moduleName) {
            try {
                const response = await fetch(`/api/cache/${moduleName}`, {
                    method: 'DELETE',
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showToast(`${capitalizeFirst(moduleName)} cache cleared`, 'success');
                } else {
                    showToast(`Clear failed: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('Failed to clear cache:', error);
                showToast('Clear failed', 'error');
            }
        }

        // Display validation result
        function displayValidationResult(moduleName, result) {
            const resultContainer = document.getElementById(`result-${moduleName}`);
            const isSuccess = result.success;
            const className = isSuccess ? 'validation-success' : 'validation-error';
            
            let content = `
                <div class="validation-result ${className}">
                    <strong>${isSuccess ? '✓ Validation successful' : '✗ Validation failed'}</strong>
                    <div>${result.message || result.error || ''}</div>
            `;
            
            // Display detailed information
            if (result.data && Object.keys(result.data).length > 0) {
                content += `
                    <div class="collapsible-details">
                        <button class="collapsible-toggle" onclick="toggleDetails('${moduleName}')">
                            Show Details
                        </button>
                        <div class="collapsible-content hidden" id="details-${moduleName}">
                            <pre>${JSON.stringify(result.data, null, 2)}</pre>
                        </div>
                    </div>
                `;
            }
            
            content += '</div>';
            resultContainer.innerHTML = content;
        }

        // Toggle details display
        function toggleDetails(moduleName) {
            const details = document.getElementById(`details-${moduleName}`);
            const toggle = details.previousElementSibling;
            
            if (details.classList.contains('hidden')) {
                details.classList.remove('hidden');
                toggle.textContent = 'Hide Details';
            } else {
                details.classList.add('hidden');
                toggle.textContent = 'Show Details';
            }
        }

        // Show Toast notification
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const messageEl = document.getElementById('toastMessage');
            
            toast.className = `toast toast-${type}`;
            messageEl.textContent = message;
            
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Refresh data
        function refreshData() {
            if (isConnected) {
                loadModules();
                loadStatistics();
            }
        }

        // Capitalize first letter
        function capitalizeFirst(str) {
            // Special handling for certain module names
            if (str === 'nodered') return 'Node-RED';
            if (str === 'home_assistant') return 'Home Assistant';
            if (str === 'openai') return 'OpenAI';
            if (str === 'deepseek') return 'DeepSeek';
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
        
        // Format file size
        function formatFileSize(bytes) {
            if (!bytes) return '';
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(1024));
            return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
        }

        // 语音转文字功能
        async function transcribeVoice(fileId, messageId, event) {
            console.log('=== Transcribe Voice Started ===');
            console.log('fileId:', fileId);
            console.log('messageId:', messageId);
            
            const transcriptionSection = document.getElementById(`transcription-${messageId}`);
            console.log('transcriptionSection found:', !!transcriptionSection);
            
            if (!transcriptionSection) {
                console.error('Transcription section not found!');
                alert('错误: 找不到转换区域，请刷新页面重试');
                return;
            }
            
            const bodyDiv = transcriptionSection.querySelector('.transcription-body');
            const button = event ? event.target : null;
            
            console.log('bodyDiv found:', !!bodyDiv);
            console.log('button found:', !!button);
            
            // 调试：检查元素的父元素链
            let parent = transcriptionSection.parentElement;
            let parentChain = [];
            while (parent) {
                const styles = window.getComputedStyle(parent);
                parentChain.push({
                    tag: parent.tagName,
                    class: parent.className,
                    display: styles.display,
                    visibility: styles.visibility,
                    overflow: styles.overflow
                });
                parent = parent.parentElement;
                if (parentChain.length > 5) break; // 只检查5层
            }
            console.log('Parent chain:', parentChain);

            // 显示转换区域
            transcriptionSection.classList.add('show');
            transcriptionSection.style.display = 'block';
            transcriptionSection.style.visibility = 'visible';
            transcriptionSection.style.position = 'relative';
            transcriptionSection.style.zIndex = '1000';
            
            console.log('Section classList:', transcriptionSection.classList.toString());
            console.log('Section display style:', transcriptionSection.style.display);
            console.log('Section offsetHeight:', transcriptionSection.offsetHeight);
            console.log('Section offsetWidth:', transcriptionSection.offsetWidth);
            
            bodyDiv.innerHTML = '<div class="transcription-loading">⏳ 正在转换语音为文字，请稍候...</div>';
            
            if (button) {
                button.disabled = true;
                button.textContent = '⏳ 转换中...';
            }

            try {
                console.log('Calling API...');
                const response = await fetch('/api/telegram/telegram/transcribe-voice', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        file_id: fileId,
                        options: {
                            language: 'zh'
                        }
                    })
                });

                const result = await response.json();
                console.log('API Response:', result);

                if (result.success && result.text) {
                    // 构建元信息
                    const metaInfo = [];
                    if (result.language) metaInfo.push(`语言: ${result.language}`);
                    if (result.duration) metaInfo.push(`时长: ${Math.round(result.duration)}秒`);
                    if (result.file_size) metaInfo.push(`大小: ${formatFileSize(result.file_size)}`);

                    // 显示结果
                    bodyDiv.innerHTML = `
                        <div class="transcription-text-content">${result.text}</div>
                        ${metaInfo.length > 0 ? `<div class="transcription-meta">${metaInfo.join(' • ')}</div>` : ''}
                    `;
                    
                    // 确保一直显示
                    transcriptionSection.classList.add('show');
                    transcriptionSection.style.display = 'block';
                    console.log('Result displayed, section should stay visible');
                    
                    // 滚动到转换结果
                    setTimeout(() => {
                        transcriptionSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }, 100);
                    
                    if (button) {
                        button.textContent = '✅ 已转换';
                        button.style.background = '#28a745';
                    }
                    
                    console.log('=== Transcription Success ===');
                } else {
                    const errorMsg = result.error || '转换失败，未返回文字内容';
                    bodyDiv.innerHTML = `<div class="transcription-error">❌ ${errorMsg}</div>`;
                    
                    // 确保错误信息也显示
                    transcriptionSection.classList.add('show');
                    transcriptionSection.style.display = 'block';
                    
                    if (button) {
                        button.disabled = false;
                        button.textContent = '📝 重试';
                    }
                    console.error('Transcription failed:', errorMsg);
                }
            } catch (error) {
                console.error('Exception:', error);
                bodyDiv.innerHTML = `<div class="transcription-error">❌ 网络错误: ${error.message}</div>`;
                
                // 确保错误信息也显示
                transcriptionSection.classList.add('show');
                transcriptionSection.style.display = 'block';
                
                if (button) {
                    button.disabled = false;
                    button.textContent = '📝 重试';
                }
            }
        }
        
        // Open media modal
        function openMediaModal(src, type, photos = null) {
            const modal = document.createElement('div');
            modal.className = 'media-modal';
            modal.onclick = (e) => {
                if (e.target === modal) {
                    closeMediaModal();
                }
            };
            
            let content = '';
            if (type === 'image') {
                content = `<img src="${src}" style="max-width: 90vw; max-height: 90vh; border-radius: 0.5rem;">`;
            } else if (type === 'video') {
                content = `<video controls style="max-width: 90vw; max-height: 90vh; border-radius: 0.5rem;">
                    <source src="${src}" type="video/mp4">
                    Your browser does not support video playback
                </video>`;
            }
            
            modal.innerHTML = `
                <div class="modal-content" style="position: relative; display: flex; align-items: center; justify-content: center;">
                    ${content}
                    <button onclick="closeMediaModal()" style="
                        position: absolute; 
                        top: 20px; 
                        right: 20px; 
                        background: rgba(0,0,0,0.5); 
                        color: white; 
                        border: none; 
                        border-radius: 50%; 
                        width: 40px; 
                        height: 40px; 
                        cursor: pointer;
                        font-size: 20px;
                    ">×</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            document.body.style.overflow = 'hidden';
        }
        
        // Close media modal
        function closeMediaModal() {
            const modal = document.querySelector('.media-modal');
            if (modal) {
                modal.remove();
                document.body.style.overflow = '';
            }
        }
        
        // ESC key closes modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeMediaModal();
            }
        });

        // =================
        // Telegram Messaging Functions
        // =================

        // Manually show Telegram message management interface
        function showTelegramMessaging() {
            console.log('Manually showing Telegram messaging interface');
            
            // Force show message management interface
            document.getElementById('telegramMessaging').classList.remove('hidden');
            
            // Scroll to message management interface
            document.getElementById('telegramMessaging').scrollIntoView({ 
                behavior: 'smooth', 
                block: 'start' 
            });
            
            // Update status and messages
            setTimeout(() => {
                updatePollingStatus();
                refreshMessages();
            }, 300);
            
            showToast('Telegram message management interface displayed', 'success');
        }

        // Check if Telegram module is available
        function checkTelegramModule() {
            console.log('Checking Telegram module...', modules.telegram);
            
            // Show interface as long as Telegram module exists and is initialized
            if (modules.telegram && modules.telegram.data && modules.telegram.data.initialized) {
                console.log('Telegram module found and initialized, showing messaging interface');
                document.getElementById('telegramMessaging').classList.remove('hidden');
                
                // Delay execution to ensure DOM is updated
                setTimeout(() => {
                    updatePollingStatus();
                    refreshMessages();
                }, 200);
                
                // Check if credentials exist
                const hasCredentials = modules.telegram.data.hasCredentials && 
                                      Object.keys(modules.telegram.data.hasCredentials).length > 0;
                
                if (hasCredentials || modules.telegram.data.enabled) {
                    console.log('Telegram module is ready for messaging');
                } else {
                    console.log('Telegram module found but may need credentials or enabling');
                }
            } else {
                console.log('Telegram module not available or not initialized:', {
                    exists: !!modules.telegram,
                    hasData: !!(modules.telegram && modules.telegram.data),
                    initialized: !!(modules.telegram && modules.telegram.data && modules.telegram.data.initialized)
                });
                document.getElementById('telegramMessaging').classList.add('hidden');
            }
        }

        // Update polling status display
        function updatePollingStatus() {
            const header = document.querySelector('.messaging-header h2');
            if (!header) {
                console.log('Messaging header not found, skipping polling status update');
                return;
            }
            
            const existingStatus = header.querySelector('.polling-status');
            
            if (existingStatus) {
                existingStatus.remove();
            }
            
            // Get actual polling status from module data
            const actualPollingStatus = modules.telegram && 
                                       modules.telegram.data && 
                                       modules.telegram.data.messaging && 
                                       modules.telegram.data.messaging.isPolling;
            
            console.log('Updating polling status:', actualPollingStatus);
            
            const statusEl = document.createElement('div');
            statusEl.className = `polling-status ${actualPollingStatus ? 'polling-active' : 'polling-inactive'}`;
            
            // More detailed status display
            const statusText = actualPollingStatus ? 'Connected' : 'Disconnected';
            const statusIcon = actualPollingStatus ? '🟢' : '🔴';
            
            statusEl.innerHTML = `
                <span class="status-dot ${actualPollingStatus ? 'status-enabled' : 'status-disabled'}"></span>
                <span>${statusIcon} ${statusText}</span>
                <span class="status-detail">${actualPollingStatus ? '(Polling active)' : '(Polling stopped)'}</span>
            `;
            
            header.appendChild(statusEl);
            
            // Update global state
            telegramPollingStatus = actualPollingStatus;
            
            // Update button status
            updatePollingButtons(actualPollingStatus);
        }
        
        // Update polling button status
        function updatePollingButtons(isPolling) {
            const startBtn = document.querySelector('button[onclick="startTelegramPolling()"]');
            const stopBtn = document.querySelector('button[onclick="stopTelegramPolling()"]');
            
            if (startBtn && stopBtn) {
                if (isPolling) {
                    startBtn.disabled = true;
                    startBtn.textContent = 'Polling Active';
                    stopBtn.disabled = false;
                    stopBtn.textContent = 'Stop Polling';
                } else {
                    startBtn.disabled = false;
                    startBtn.textContent = 'Start Polling';
                    stopBtn.disabled = true;
                    stopBtn.textContent = 'Polling Stopped';
                }
            }
        }

        // Start Telegram polling
        async function startTelegramPolling() {
            try {
                // Show start status
                showToast('Starting Telegram polling...', 'info');
                
                const response = await fetch('/api/telegram/telegram/polling/start', {
                    method: 'POST',
                });
                
                const data = await response.json();
                
                if (data.success) {
                    telegramPollingStatus = true;
                    showToast('🟢 Telegram polling started, system connected', 'success');
                    
                    // Immediately update status display
                    updatePollingButtons(true);
                    
                    // Refresh module status to get latest polling status
                    loadModules();
                    
                    // Delay update status and refresh messages
                    setTimeout(() => {
                        updatePollingStatus();
                        refreshMessages();
                    }, 1000);
                    
                    // Regularly check connection status
                    startConnectionMonitoring();
                } else {
                    showToast(`❌ Failed to start polling: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('Failed to start polling:', error);
                showToast('❌ Failed to start polling: Network error', 'error');
            }
        }
        
        // Connection monitoring disabled - no auto refresh
        let connectionMonitorInterval = null;
        function startConnectionMonitoring() {
            // Auto refresh disabled as requested
            return;
        }
        
        function stopConnectionMonitoring() {
            if (connectionMonitorInterval) {
                clearInterval(connectionMonitorInterval);
                connectionMonitorInterval = null;
            }
        }

        // Stop Telegram polling
        async function stopTelegramPolling() {
            try {
                showToast('Stopping Telegram polling...', 'info');
                
                const response = await fetch('/api/telegram/telegram/polling/stop', {
                    method: 'POST',
                });
                
                const data = await response.json();
                
                if (data.success) {
                    telegramPollingStatus = false;
                    showToast('🔴 Telegram polling stopped, connection disconnected', 'success');
                    
                    // Immediately update status display
                    updatePollingButtons(false);
                    
                    // Stop connection monitoring
                    stopConnectionMonitoring();
                    
                    // Refresh module status to get latest polling status
                    loadModules();
                    setTimeout(() => {
                        updatePollingStatus();
                    }, 500);
                } else {
                    showToast(`❌ Failed to stop polling: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('Failed to stop polling:', error);
                showToast('❌ Failed to stop polling: Network error', 'error');
            }
        }

        // Refresh message list
        async function refreshMessages() {
            try {
                const response = await fetch('/api/telegram/telegram/messages?limit=50', {
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Messages loaded:', data.data);
                    renderMessages(data.data.messages || []);
                } else {
                    console.error('Failed to load messages, status:', response.status);
                    // If no API key, show prompt information
                    if (response.status === 401) {
                        renderMessages([], 'Please configure API key first');
                    }
                }
            } catch (error) {
                console.error('Failed to refresh messages:', error);
                renderMessages([], 'Failed to load messages');
            }
        }

        // Render message list
        function renderMessages(messages, errorMsg = null) {
            const messagesList = document.getElementById('messagesList');
            
            // Update statistics
            updateMessageStats(messages, errorMsg);
            
            if (errorMsg) {
                messagesList.innerHTML = `<p style="text-align: center; color: var(--danger-color); padding: 2rem;">${errorMsg}</p>`;
                return;
            }
            
            if (messages.length === 0) {
                messagesList.innerHTML = '<p style="text-align: center; color: var(--gray-500); padding: 2rem;">No messages - Please start polling to receive messages</p>';
                return;
            }
            
            // Sort messages by time in descending order
            const sortedMessages = messages.sort((a, b) => new Date(b.date) - new Date(a.date));
            
            messagesList.innerHTML = sortedMessages.map(message => `
                <div class="message-item">
                    <div class="message-header">
                        <div class="message-from">
                            ${message.from?.username ? `@${message.from.username}` : message.from?.first_name || 'Unknown'}
                            ${message.chat_type && message.chat_type !== 'private' ? ` (${message.chat_type})` : ''}
                        </div>
                        <div class="message-actions">
                            <button class="btn btn-sm btn-primary" onclick="replyToMessage('${message.chat_id}', '${message.from?.username ? `@${message.from.username}` : message.from?.first_name || 'Unknown'}')">
                                Reply
                            </button>
                            <div class="message-time">
                                ${new Date(message.date).toLocaleString()}
                            </div>
                        </div>
                    </div>
                    <div class="message-content">
                        <span class="message-type">${message.message_type}</span>
                        ${message.text ? `<div class="message-text">${message.text}</div>` : ''}
                        ${message.caption ? `<div class="message-text"><em>${message.caption}</em></div>` : ''}
                        ${message.media ? `
                            <div class="message-media">
                                ${Object.keys(message.media).map(type => {
                                    const mediaData = message.media[type];
                                    const fileId = mediaData.file_id || mediaData[0]?.file_id;
                                    if (!fileId) return '';
                                    
                                    switch(type) {
                                        case 'photo':
                                            // Get highest quality image
                                            const photos = Array.isArray(mediaData) ? mediaData : [mediaData];
                                            const bestPhoto = photos.reduce((best, current) => {
                                                const bestSize = (best.width || 0) * (best.height || 0);
                                                const currentSize = (current.width || 0) * (current.height || 0);
                                                return currentSize > bestSize ? current : best;
                                            });
                                            
                                            return `<div class="media-item">
                                                <img src="/api/telegram/telegram/file-url/${bestPhoto.file_id}" 
                                                     alt="Image" 
                                                     class="media-image"
                                                     onclick="openMediaModal('/api/telegram/telegram/file-url/${bestPhoto.file_id}', 'image', ${JSON.stringify(photos).replace(/"/g, '&quot;')})"
                                                     loading="lazy"
                                                     data-photos='${JSON.stringify(photos).replace(/"/g, '&quot;')}'>
                                                <div class="media-info">
                                                    📷 Image ${bestPhoto.width ? `${bestPhoto.width}×${bestPhoto.height}` : ''}
                                                    ${photos.length > 1 ? ` (${photos.length} sizes)` : ''}
                                                </div>
                                            </div>`;
                                        case 'video':
                                            const videoWidth = mediaData.width || 320;
                                            const videoHeight = mediaData.height || 240;
                                            const videoDuration = mediaData.duration ? `${Math.floor(mediaData.duration / 60)}:${String(mediaData.duration % 60).padStart(2, '0')}` : '';
                                            const videoSize = mediaData.file_size ? formatFileSize(mediaData.file_size) : '';
                                            
                                            return `<div class="media-item">
                                                <video controls class="media-video" preload="metadata" 
                                                       width="${Math.min(videoWidth, 400)}" 
                                                       onclick="openMediaModal('/api/telegram/telegram/file-url/${fileId}', 'video')">
                                                    <source src="/api/telegram/telegram/file-url/${fileId}" type="video/mp4">
                                                    Your browser does not support video playback
                                                </video>
                                                <div class="media-info">
                                                    🎥 Video ${videoWidth}×${videoHeight} ${videoDuration} ${videoSize}
                                                </div>
                                            </div>`;
                                        case 'video_note':
                                            const noteDuration = mediaData.duration ? `${mediaData.duration}s` : '';
                                            const noteSize = mediaData.file_size ? formatFileSize(mediaData.file_size) : '';
                                            
                                            return `<div class="media-item">
                                                <video controls class="media-video media-video-note" preload="metadata"
                                                       style="border-radius: 50%; width: 240px; height: 240px; object-fit: cover;"
                                                       onclick="openMediaModal('/api/telegram/telegram/file-url/${fileId}', 'video')">
                                                    <source src="/api/telegram/telegram/file-url/${fileId}" type="video/mp4">
                                                    Your browser does not support video playback
                                                </video>
                                                <div class="media-info">
                                                    🎬 Video message ${noteDuration} ${noteSize}
                                                </div>
                                            </div>`;
                                        case 'voice':
                                            const voiceDuration = mediaData.duration ? `${Math.floor(mediaData.duration / 60)}:${String(mediaData.duration % 60).padStart(2, '0')}` : '';
                                            const voiceSize = mediaData.file_size ? formatFileSize(mediaData.file_size) : '';
                                            const voiceFileId = mediaData.file_id;
                                            
                                            return `<div class="voice-container">
                                                <div class="voice-player-section">
                                                    <audio controls class="media-audio" preload="metadata">
                                                        <source src="/api/telegram/telegram/file-url/${fileId}" type="audio/ogg">
                                                        <source src="/api/telegram/telegram/file-url/${fileId}" type="audio/mpeg">
                                                        Your browser does not support audio playback
                                                    </audio>
                                                    <div class="voice-meta">
                                                        <span class="voice-info">🎵 ${voiceDuration} ${voiceSize}</span>
                                                        <button class="transcribe-btn" onclick="transcribeVoice('${voiceFileId}', ${message.id}, event)">
                                                            📝 转文字
                                                        </button>
                                                    </div>
                                                </div>
                                                <div class="transcription-section" id="transcription-${message.id}">
                                                    <div class="transcription-header">转换结果：</div>
                                                    <div class="transcription-body"></div>
                                                </div>
                                            </div>`;
                                        case 'audio':
                                            const audioDuration = mediaData.duration ? `${Math.floor(mediaData.duration / 60)}:${String(mediaData.duration % 60).padStart(2, '0')}` : '';
                                            const audioTitle = mediaData.title || mediaData.file_name || 'Audio file';
                                            const audioPerformer = mediaData.performer ? ` - ${mediaData.performer}` : '';
                                            const audioSize = mediaData.file_size ? formatFileSize(mediaData.file_size) : '';
                                            
                                            return `<div class="media-item">
                                                <audio controls class="media-audio" preload="metadata">
                                                    <source src="/api/telegram/telegram/file-url/${fileId}" type="audio/mpeg">
                                                    <source src="/api/telegram/telegram/file-url/${fileId}" type="audio/ogg">
                                                    Your browser does not support audio playback
                                                </audio>
                                                <div class="media-info">🎵 ${audioTitle}${audioPerformer} ${audioDuration} ${audioSize}</div>
                                            </div>`;
                                        case 'document':
                                            const docName = mediaData.file_name || 'Document file';
                                            const docSize = mediaData.file_size ? formatFileSize(mediaData.file_size) : '';
                                            const mimeType = mediaData.mime_type || '';
                                            
                                            // Determine if it's an image or video document
                                            if (mimeType.startsWith('image/')) {
                                                return `<div class="media-item">
                                                    <img src="/api/telegram/telegram/file-url/${fileId}" 
                                                         alt="${docName}" 
                                                         class="media-image"
                                                         onclick="openMediaModal('/api/telegram/telegram/file-url/${fileId}', 'image')"
                                                         loading="lazy">
                                                    <div class="media-info">📷 ${docName} ${docSize}</div>
                                                </div>`;
                                            } else if (mimeType.startsWith('video/')) {
                                                return `<div class="media-item">
                                                    <video controls class="media-video" preload="metadata"
                                                           onclick="openMediaModal('/api/telegram/telegram/file-url/${fileId}', 'video')">
                                                        <source src="/api/telegram/telegram/file-url/${fileId}" type="${mimeType}">
                                                        Your browser does not support video playback
                                                    </video>
                                                    <div class="media-info">🎥 ${docName} ${docSize}</div>
                                                </div>`;
                                            } else if (mimeType.startsWith('audio/')) {
                                                return `<div class="media-item">
                                                    <audio controls class="media-audio" preload="metadata">
                                                        <source src="/api/telegram/telegram/file-url/${fileId}" type="${mimeType}">
                                                        Your browser does not support audio playback
                                                    </audio>
                                                    <div class="media-info">🎵 ${docName} ${docSize}</div>
                                                </div>`;
                                            } else {
                                            return `<div class="media-item">
                                                <div class="media-document" onclick="downloadFile('${fileId}')">
                                                        📄 ${docName}
                                                </div>
                                                    <div class="media-info">${docSize} - Click to download</div>
                                                </div>`;
                                            }
                                        case 'sticker':
                                            const stickerEmoji = mediaData.emoji || '🎭';
                                            const stickerSize = mediaData.file_size ? formatFileSize(mediaData.file_size) : '';
                                            
                                            return `<div class="media-item">
                                                <img src="/api/telegram/telegram/file-url/${fileId}" 
                                                     alt="Sticker ${stickerEmoji}" 
                                                     class="media-image media-sticker"
                                                     style="max-width: 200px; max-height: 200px;"
                                                     onclick="openMediaModal('/api/telegram/telegram/file-url/${fileId}', 'image')"
                                                     loading="lazy">
                                                <div class="media-info">${stickerEmoji} Sticker ${stickerSize}</div>
                                            </div>`;
                                        case 'animation':
                                            const animationName = mediaData.file_name || 'GIF animation';
                                            const animationSize = mediaData.file_size ? formatFileSize(mediaData.file_size) : '';
                                            const animationDuration = mediaData.duration ? `${mediaData.duration}s` : '';
                                            
                                            return `<div class="media-item">
                                                <video controls class="media-video" preload="metadata" autoplay loop muted
                                                       onclick="openMediaModal('/api/telegram/telegram/file-url/${fileId}', 'video')">
                                                    <source src="/api/telegram/telegram/file-url/${fileId}" type="${mediaData.mime_type || 'video/mp4'}">
                                                    Your browser does not support animation playback
                                                </video>
                                                <div class="media-info">🎬 ${animationName} ${animationDuration} ${animationSize}</div>
                                            </div>`;
                                        default:
                                            return `<div class="media-item">
                                                <div class="media-info">${type}: ${fileId}</div>
                                            </div>`;
                                    }
                                }).join('')}
                            </div>
                        ` : ''}
                    </div>
                </div>
            `).join('');
        }

        // Reply to message
        function replyToMessage(chatId, fromName) {
            // Auto-fill chat ID
            document.getElementById('sendChatId').value = chatId;
            
            // Switch to send message tab
            switchTab('send');
            
            // Show prompt information
            showToast(`Selected reply to: ${fromName} (${chatId})`, 'success');
            
            // Scroll to send form
            document.getElementById('tab-send').scrollIntoView({ 
                behavior: 'smooth', 
                block: 'start' 
            });
        }

        // Open media modal
        function openMediaModal(src, type, photos = null) {
            if (type === 'image') {
                // Create image modal
                const modal = document.createElement('div');
                modal.className = 'media-modal';
                
                let photoSelector = '';
                if (photos && photos.length > 1) {
                    photoSelector = `
                        <div class="photo-selector">
                            <label>Select size:</label>
                            <select id="photoSizeSelect" onchange="changePhotoSize(this.value)">
                                ${photos.map((photo, index) => `
                                    <option value="${photo.file_id}" ${photo.file_id === src.split('/').pop() ? 'selected' : ''}>
                                        ${photo.width}×${photo.height} ${photo.file_size ? `(${Math.round(photo.file_size/1024)}KB)` : ''}
                                    </option>
                                `).join('')}
                            </select>
                        </div>
                    `;
                }
                
                modal.innerHTML = `
                    <div class="modal-content">
                        <span class="modal-close" onclick="closeMediaModal()">&times;</span>
                        ${photoSelector}
                        <img src="${src}" alt="Image" class="modal-image" id="modalImage">
                        <div class="image-info" id="imageInfo"></div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Update image information
                updateImageInfo(src, photos);
                
                // Click background to close
                modal.onclick = function(e) {
                    if (e.target === modal) {
                        closeMediaModal();
                    }
                };
            }
        }

        // Switch image size
        function changePhotoSize(fileId) {
            const modalImage = document.getElementById('modalImage');
            const newSrc = `/api/telegram/telegram/file-url/${fileId}`;
            modalImage.src = newSrc;
            
            // Update image information
            const select = document.getElementById('photoSizeSelect');
            const selectedOption = select.options[select.selectedIndex];
            const dimensions = selectedOption.text.split(' ')[0];
            document.getElementById('imageInfo').textContent = `Size: ${dimensions}`;
        }

        // Update image information
        function updateImageInfo(src, photos) {
            if (photos && photos.length > 0) {
                const currentFileId = src.split('/').pop();
                const currentPhoto = photos.find(p => p.file_id === currentFileId);
                if (currentPhoto) {
                    const info = `Size: ${currentPhoto.width}×${currentPhoto.height}`;
                    if (currentPhoto.file_size) {
                        info += ` | Size: ${Math.round(currentPhoto.file_size/1024)}KB`;
                    }
                    document.getElementById('imageInfo').textContent = info;
                }
            }
        }

        // Close media modal
        function closeMediaModal() {
            const modal = document.querySelector('.media-modal');
            if (modal) {
                modal.remove();
            }
        }

        // Download file
        async function downloadFile(fileId) {
            try {
                showToast('Getting file...', 'info');
                
                const response = await fetch(`/api/telegram/telegram/file-url/${fileId}`, {
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    // Create download link
                    const link = document.createElement('a');
                    link.href = result.data.file_url;
                    link.download = `telegram_file_${fileId}`;
                    link.target = '_blank';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    showToast('File download started', 'success');
                } else {
                    showToast(`Download failed: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error('Download error:', error);
                showToast('Download failed: Network error', 'error');
            }
        }

        // Test API endpoint
        async function testApi(method, url, data = null) {
            const resultsContainer = document.getElementById('apiTestResults');
            const timestamp = new Date().toLocaleTimeString();
            
            // Show test start information
            const testId = `test-${Date.now()}`;
            resultsContainer.innerHTML = `
                <div class="test-result info" id="${testId}">
                    <strong>🧪 Test ${method} ${url}</strong>
                    <div>Time: ${timestamp}</div>
                    <div>Status: Testing...</div>
                </div>
            `;
            
            try {
                const options = {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json'
                    }
                };
                
                
                // Add request body (if POST/PUT request)
                if (data && (method === 'POST' || method === 'PUT')) {
                    options.body = JSON.stringify(data);
                }
                
                const response = await fetch(url, options);
                const responseData = await response.text();
                
                let parsedData;
                try {
                    parsedData = JSON.parse(responseData);
                } catch (e) {
                    parsedData = responseData;
                }
                
                const resultClass = response.ok ? 'success' : 'error';
                const statusText = response.ok ? '✅ Success' : '❌ Failed';
                
                document.getElementById(testId).innerHTML = `
                    <strong>🧪 Test ${method} ${url}</strong>
                    <div>Time: ${timestamp}</div>
                    <div>Status: ${statusText} (HTTP ${response.status})</div>
                    <div>Response time: ${Date.now() - parseInt(testId.split('-')[1])}ms</div>
                    <pre>${JSON.stringify(parsedData, null, 2)}</pre>
                `;
                document.getElementById(testId).className = `test-result ${resultClass}`;
                
            } catch (error) {
                document.getElementById(testId).innerHTML = `
                    <strong>🧪 Test ${method} ${url}</strong>
                    <div>Time: ${timestamp}</div>
                    <div>Status: ❌ Network error</div>
                    <div>Error: ${error.message}</div>
                `;
                document.getElementById(testId).className = 'test-result error';
            }
        }

        // Update message statistics
        function updateMessageStats(messages, errorMsg = null) {
            const totalMessagesEl = document.getElementById('totalMessages');
            const lastUpdateEl = document.getElementById('lastUpdate');
            
            if (errorMsg) {
                totalMessagesEl.textContent = '-';
                lastUpdateEl.textContent = 'Error';
                return;
            }
            
            totalMessagesEl.textContent = messages.length;
            
            if (messages.length > 0) {
                const latestMessage = messages.reduce((latest, current) => 
                    new Date(current.date) > new Date(latest.date) ? current : latest
                );
                lastUpdateEl.textContent = new Date(latestMessage.date).toLocaleTimeString();
            } else {
                lastUpdateEl.textContent = '-';
            }
        }

        // Clear message history
        async function clearMessages() {
            if (!confirm('Are you sure you want to clear all message history?')) {
                return;
            }
            
            try {
                const response = await fetch('/api/telegram/telegram/messages', {
                    method: 'DELETE',
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showToast('Message history cleared', 'success');
                    refreshMessages();
                } else {
                    showToast(`Clear failed: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('Failed to clear messages:', error);
                showToast('Clear failed', 'error');
            }
        }
        
        // Reprocess message media data
        async function reprocessMessages() {
            try {
                showToast('Reprocessing message media data...', 'info');
                
                const response = await fetch('/api/telegram/telegram/reprocess-messages', {
                    method: 'POST',
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const { reprocessed, total } = data.data;
                    showToast(`✅ Reprocessing completed: ${reprocessed}/${total} messages updated with media data`, 'success');
                    
                    // Refresh message display
                    setTimeout(() => {
                        refreshMessages();
                    }, 1000);
                } else {
                    showToast(`❌ Reprocessing failed: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('Failed to reprocess messages:', error);
                showToast('❌ Reprocessing failed: Network error', 'error');
            }
        }

        // Switch tab
        function switchTab(tabName) {
            // Hide all tab content
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active state from all tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(`tab-${tabName}`).classList.add('active');
            
            // Activate selected tab button
            event.target.classList.add('active');
        }

        // Update send form
        function updateSendForm() {
            const messageType = document.getElementById('sendMessageType').value;
            const textGroup = document.getElementById('textMessageGroup');
            const mediaGroup = document.getElementById('mediaMessageGroup');
            
            if (messageType === 'text') {
                textGroup.classList.remove('hidden');
                mediaGroup.classList.add('hidden');
            } else {
                textGroup.classList.add('hidden');
                mediaGroup.classList.remove('hidden');
            }
        }

        // Send Telegram message
        async function sendTelegramMessage() {
            const chatId = document.getElementById('sendChatId').value.trim();
            const messageType = document.getElementById('sendMessageType').value;
            const text = document.getElementById('sendText').value.trim();
            const media = document.getElementById('sendMedia').value.trim();
            const caption = document.getElementById('sendCaption').value.trim();
            
            if (!chatId) {
                showToast('Please enter chat ID', 'error');
                return;
            }
            
            if (messageType === 'text' && !text) {
                showToast('Please enter message content', 'error');
                return;
            }
            
            if (messageType !== 'text' && !media) {
                showToast('Please enter media file ID or URL', 'error');
                return;
            }
            
            // Show send status
            const sendButton = event.target;
            const originalText = sendButton.textContent;
            sendButton.textContent = 'Sending...';
            sendButton.disabled = true;
            
            try {
                let endpoint = '';
                let payload = {
                    chat_id: chatId,
                    options: {}
                };
                
                if (caption) {
                    payload.options.caption = caption;
                }
                
                switch (messageType) {
                    case 'text':
                        endpoint = '/api/telegram/telegram/send/message';
                        payload.text = text;
                        break;
                    case 'photo':
                        endpoint = '/api/telegram/telegram/send/photo';
                        payload.photo = media;
                        break;
                    case 'video':
                        endpoint = '/api/telegram/telegram/send/video';
                        payload.video = media;
                        break;
                    case 'voice':
                        endpoint = '/api/telegram/telegram/send/voice';
                        payload.voice = media;
                        break;
                    case 'document':
                        endpoint = '/api/telegram/telegram/send/document';
                        payload.document = media;
                        break;
                }
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showToast('Message sent successfully', 'success');
                    // Clear form
                    document.getElementById('sendChatId').value = '';
                    document.getElementById('sendText').value = '';
                    document.getElementById('sendMedia').value = '';
                    document.getElementById('sendCaption').value = '';
                } else {
                    showToast(`Send failed: ${data.error}`, 'error');
                    console.error('Send message error:', data);
                }
            } catch (error) {
                console.error('Failed to send message:', error);
                showToast('Send failed: Network error', 'error');
            } finally {
                // Restore button status
                sendButton.textContent = originalText;
                sendButton.disabled = false;
            }
        }

        // Set Webhook
        async function setWebhook() {
            const webhookUrl = document.getElementById('webhookUrl').value.trim();
            const webhookSecret = document.getElementById('webhookSecret').value.trim();
            
            if (!webhookUrl) {
                showToast('Please enter Webhook URL', 'error');
                return;
            }
            
            // Validate URL format
            try {
                new URL(webhookUrl);
            } catch (e) {
                showToast('Please enter a valid URL', 'error');
                return;
            }
            
            const setButton = event.target;
            const originalText = setButton.textContent;
            setButton.textContent = 'Setting...';
            setButton.disabled = true;
            
            try {
                const payload = {
                    webhook_url: webhookUrl,
                    options: {}
                };
                
                if (webhookSecret) {
                    payload.options.secret_token = webhookSecret;
                }
                
                const response = await fetch('/api/telegram/telegram/webhook/set', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });
                
                const data = await response.json();
                displayWebhookStatus(data, data.success ? 'success' : 'error');
                
                if (data.success) {
                    showToast('Webhook settings saved', 'success');
                }
            } catch (error) {
                console.error('Failed to set webhook:', error);
                displayWebhookStatus({ success: false, error: 'Setting failed: Network error' }, 'error');
            } finally {
                setButton.textContent = originalText;
                setButton.disabled = false;
            }
        }

        // Remove Webhook
        async function removeWebhook() {
            if (!confirm('Are you sure you want to remove the current Webhook settings?')) {
                return;
            }
            
            const removeButton = event.target;
            const originalText = removeButton.textContent;
            removeButton.textContent = 'Removing...';
            removeButton.disabled = true;
            
            try {
                const response = await fetch('/api/telegram/telegram/webhook', {
                    method: 'DELETE',
                });
                
                const data = await response.json();
                displayWebhookStatus(data, data.success ? 'success' : 'error');
                
                if (data.success) {
                    showToast('Webhook removed', 'success');
                    // Clear form
                    document.getElementById('webhookUrl').value = '';
                    document.getElementById('webhookSecret').value = '';
                }
            } catch (error) {
                console.error('Failed to remove webhook:', error);
                displayWebhookStatus({ success: false, error: 'Removal failed: Network error' }, 'error');
            } finally {
                removeButton.textContent = originalText;
                removeButton.disabled = false;
            }
        }

        // Get Webhook information
        async function getWebhookInfo() {
            const infoButton = event.target;
            const originalText = infoButton.textContent;
            infoButton.textContent = 'Getting...';
            infoButton.disabled = true;
            
            try {
                const response = await fetch('/api/telegram/telegram/webhook', {
                });
                
                const data = await response.json();
                displayWebhookStatus(data, 'info');
                
                if (data.success && data.data) {
                    // If webhook is set, fill the form
                    if (data.data.url) {
                        document.getElementById('webhookUrl').value = data.data.url;
                    }
                }
            } catch (error) {
                console.error('Failed to get webhook info:', error);
                displayWebhookStatus({ success: false, error: 'Failed to get information: Network error' }, 'error');
            } finally {
                infoButton.textContent = originalText;
                infoButton.disabled = false;
            }
        }

        // Display Webhook status
        function displayWebhookStatus(data, type) {
            const statusEl = document.getElementById('webhookStatus');
            const className = `webhook-status ${type}`;
            
            let content = '';
            if (data.success) {
                content = `<strong>✓ ${data.message || 'Operation successful'}</strong>`;
                if (data.data) {
                    content += `<pre style="margin-top: 0.5rem; font-size: 0.8rem;">${JSON.stringify(data.data, null, 2)}</pre>`;
                }
            } else {
                content = `<strong>✗ ${data.error || 'Operation failed'}</strong>`;
            }
            
            statusEl.innerHTML = `<div class="${className}">${content}</div>`;
        }

        // =================
        // API documentation management functions
        // =================

        // Show API documentation
        function showApiDocumentation() {
            document.getElementById('apiDocumentation').classList.remove('hidden');
            document.getElementById('apiDocumentation').scrollIntoView({ 
                behavior: 'smooth', 
                block: 'start' 
            });
            showToast('API documentation displayed', 'success');
        }
        
        // Show QR code
        async function showQRCode() {
            console.log('showQRCode function called');
            
            const modal = document.getElementById('qrModal');
            const qrCodeContainer = document.getElementById('qrCode');
            const qrUrlElement = document.getElementById('qrUrl');
            
            if (!modal || !qrCodeContainer || !qrUrlElement) {
                console.error('QR Code elements not found');
                showToast('QR Code elements not found', 'error');
                return;
            }
            
            // Show loading status
            qrCodeContainer.innerHTML = '<div style="text-align: center; padding: 2rem;"><div class="spinner"></div><p>Loading...</p></div>';
            modal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
            
            try {
                // Get server information (including LAN IP)
                const response = await fetch('/api/server-info');
                const serverInfo = await response.json();
                
                const lanUrl = serverInfo.url;
                qrUrlElement.textContent = lanUrl;
                
                // Clear loading status
                qrCodeContainer.innerHTML = '';
                
                // Check if QR library is loaded, if not use online QR code generation service
                if (typeof QR === 'undefined') {
                    console.log('QR library not loaded, using online QR service');
                    // Use online QR code generation service
                    const qrImageUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(lanUrl)}`;
                    qrCodeContainer.innerHTML = `
                        <img src="${qrImageUrl}" 
                             alt="QR Code for ${lanUrl}" 
                             style="border: 1px solid #ddd; border-radius: 0.5rem; max-width: 200px; max-height: 200px;"
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div style="display: none; border: 2px dashed #ccc; padding: 2rem; border-radius: 0.5rem; background: #f9f9f9; text-align: center;">
                            <div style="font-size: 3rem; margin-bottom: 0.5rem;">📱</div>
                            <p style="color: #666; margin: 0;">QR Code generation failed</p>
                            <p style="color: #999; font-size: 0.9rem; margin: 0.5rem 0 0 0;">Please copy the URL below:</p>
                        </div>
                    `;
                    return;
                }
                
                try {
                    // Generate QR code
                    const qr = new QR({
                        text: lanUrl,
                        width: 200,
                        height: 200,
                        colorDark: '#000000',
                        colorLight: '#FFFFFF'
                    });
                    
                    // Create canvas element
                    const canvas = document.createElement('canvas');
                    canvas.width = 200;
                    canvas.height = 200;
                    canvas.style.border = '1px solid #ddd';
                    canvas.style.borderRadius = '0.5rem';
                    
                    // Draw QR code
                    qr.draw(canvas);
                    
                    // Add to container
                    qrCodeContainer.appendChild(canvas);
                    
                    console.log('QR Code generated successfully');
                } catch (error) {
                    console.error('QR Code generation failed:', error);
                    qrCodeContainer.innerHTML = `
                        <div style="border: 2px dashed #ccc; padding: 2rem; border-radius: 0.5rem; background: #f9f9f9; text-align: center;">
                            <div style="font-size: 3rem; margin-bottom: 0.5rem;">📱</div>
                            <p style="color: #666; margin: 0;">Failed to generate QR code</p>
                            <p style="color: #999; font-size: 0.9rem; margin: 0.5rem 0 0 0;">Please copy the URL below:</p>
                        </div>
                    `;
                }
                
            } catch (error) {
                console.error('Failed to get server info:', error);
                // Use current URL as fallback
                const currentUrl = window.location.href;
                qrUrlElement.textContent = currentUrl;
                
                qrCodeContainer.innerHTML = `
                    <div style="border: 2px dashed #ccc; padding: 2rem; border-radius: 0.5rem; background: #f9f9f9; text-align: center;">
                        <div style="font-size: 3rem; margin-bottom: 0.5rem;">📱</div>
                        <p style="color: #666; margin: 0;">Failed to get LAN IP</p>
                        <p style="color: #999; font-size: 0.9rem; margin: 0.5rem 0 0 0;">Using current URL:</p>
                    </div>
                `;
            }
        }
        
        // Close QR code
        function closeQRCode() {
            const modal = document.getElementById('qrModal');
            modal.classList.add('hidden');
            document.body.style.overflow = '';
        }
        
        // ESC key closes QR code
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeQRCode();
            }
        });
        

        // Show all API documentation
        function showAllApiDocs() {
            showApiDocumentation();
            switchApiTab('overview');
        }

        // Show Telegram API documentation
        function showTelegramApiDocs() {
            showApiDocumentation();
            switchApiTab('telegram');
        }

        // Show Home Assistant API documentation
        function showHomeAssistantApiDocs() {
            showApiDocumentation();
            switchApiTab('home_assistant');
        }

        // Switch API tab
        function switchApiTab(tabName) {
            // Hide all API tab content
            document.querySelectorAll('#apiDocumentation .tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active state from all API tab buttons
            document.querySelectorAll('#apiDocumentation .tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(`api-tab-${tabName}`).classList.add('active');
            
            // Activate selected tab button
            event.target.classList.add('active');
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl/Cmd + R refresh data
            if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                e.preventDefault();
                refreshData();
                showToast('Data refreshed', 'success');
            }
            
            // Escape key closes details
            if (e.key === 'Escape') {
                document.querySelectorAll('.collapsible-content:not(.hidden)').forEach(el => {
                    el.classList.add('hidden');
                    el.previousElementSibling.textContent = 'Show Details';
                });
            }
        });

        // Health Check Functions
        async function runHealthCheck() {
            const resultsContainer = document.getElementById('healthResults');
            resultsContainer.innerHTML = '<div class="health-item"><div class="health-item-info">🔄 Running health check...</div></div>';
            
            const healthResults = [];
            
            // Check each module
            for (const [moduleName, moduleData] of Object.entries(modules)) {
                // Skip agent module
                if (moduleName === 'agent') continue;
                
                const healthResult = await checkModuleHealth(moduleName, moduleData);
                healthResults.push(healthResult);
            }
            
            // Render results
            renderHealthResults(healthResults);
        }

        async function checkModuleHealth(moduleName, moduleData) {
            const result = {
                name: moduleName,
                status: 'unknown',
                message: '',
                details: {}
            };

            try {
                const isInitialized = moduleData.data && moduleData.data.initialized;
                
                if (!isInitialized) {
                    result.status = 'warning';
                    result.message = 'Module not initialized';
                    return result;
                }

                // Try to fetch credentials to verify they exist
                let hasValidCredentials = false;
                try {
                    const credsResponse = await fetch(`/api/credentials/${moduleName}`);
                    if (credsResponse.ok) {
                        const credsData = await credsResponse.json();
                        if (credsData.success && credsData.data && Object.keys(credsData.data).length > 0) {
                            hasValidCredentials = true;
                        }
                    }
                } catch (error) {
                    // Ignore credential fetch errors, will be caught by module-specific health check
                }

                if (!hasValidCredentials) {
                    result.status = 'warning';
                    result.message = 'No credentials configured';
                    return result;
                }

                // Module-specific health checks
                switch (moduleName) {
                    case 'telegram':
                        result.details = await checkTelegramHealth(moduleData);
                        break;
                    case 'home_assistant':
                        result.details = await checkHomeAssistantHealth(moduleData);
                        break;
                    case 'claude':
                    case 'gemini':
                    case 'openai':
                    case 'deepseek':
                        result.details = await checkAIHealth(moduleName, moduleData);
                        break;
                    case 'nodered':
                        result.details = await checkNodeRedHealth(moduleData);
                        break;
                    default:
                        result.details = await checkGenericHealth(moduleName, moduleData);
                }

                // Determine overall status
                if (result.details && result.details.valid) {
                    result.status = 'healthy';
                    result.message = result.details.message || 'Service is healthy';
                } else if (result.details && result.details.error) {
                    result.status = 'error';
                    result.message = result.details.error || 'Service validation failed';
                } else {
                    result.status = 'warning';
                    result.message = 'Unable to verify service health';
                }

            } catch (error) {
                result.status = 'error';
                result.message = `Health check failed: ${error.message}`;
            }

            return result;
        }

        async function checkTelegramHealth(moduleData) {
            try {
                // Check if polling is active
                const isPolling = moduleData.data?.messaging?.isPolling;
                const messageCount = moduleData.data?.stats?.messageCount || 0;
                
                // If polling is active, consider it healthy
                if (isPolling) {
                    return {
                        valid: true,
                        message: `Bot is polling (${messageCount} messages)`,
                        polling: true,
                        messageCount: messageCount
                    };
                }
                
                // If not polling, try to validate token
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5秒超时
                
                try {
                    const response = await fetch('/api/telegram/telegram/bot-info', {
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    const data = await response.json();
                    
                    if (data.success) {
                        return {
                            valid: true,
                            message: 'Bot token is valid (not polling)',
                            botInfo: data.data,
                            polling: false
                        };
                    } else {
                        return {
                            valid: false,
                            error: data.error || 'Token validation failed'
                        };
                    }
                } catch (fetchError) {
                    clearTimeout(timeoutId);
                    if (fetchError.name === 'AbortError') {
                        // Timeout, but if we have credentials, assume it's OK
                        return {
                            valid: true,
                            message: 'Bot configured (API timeout)',
                            polling: false,
                            warning: 'API validation timed out'
                        };
                    }
                    throw fetchError;
                }
            } catch (error) {
                return {
                    valid: false,
                    error: `Telegram health check error: ${error.message}`
                };
            }
        }

        async function checkHomeAssistantHealth(moduleData) {
            try {
                // Test Home Assistant connection with timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5秒超时
                
                const response = await fetch('/api/home_assistant/home_assistant/config', {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                const data = await response.json();
                
                if (data.success) {
                    return {
                        valid: true,
                        message: 'Home Assistant connection successful',
                        version: data.data?.version
                    };
                } else {
                    return {
                        valid: false,
                        error: data.error || 'Home Assistant connection failed'
                    };
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    return {
                        valid: false,
                        error: 'Home Assistant connection timeout'
                    };
                }
                return {
                    valid: false,
                    error: `Home Assistant error: ${error.message}`
                };
            }
        }

        async function checkAIHealth(moduleName, moduleData) {
            try {
                // Test AI service connection
                const response = await fetch(`/api/${moduleName}/${moduleName}/models`);
                const data = await response.json();
                
                if (data.success) {
                    return {
                        valid: true,
                        message: `${moduleName} API is accessible`,
                        models: data.data?.length || 0
                    };
                } else {
                    return {
                        valid: false,
                        error: `${moduleName} API validation failed`
                    };
                }
            } catch (error) {
                return {
                    valid: false,
                    error: `${moduleName} API error: ${error.message}`
                };
            }
        }

        async function checkNodeRedHealth(moduleData) {
            try {
                // Test Node-RED connection
                const response = await fetch('/api/nodered/nodered/flows');
                const data = await response.json();
                
                if (data.success) {
                    return {
                        valid: true,
                        message: 'Node-RED is accessible',
                        flowCount: data.data?.length || 0
                    };
                } else {
                    return {
                        valid: false,
                        error: 'Node-RED connection failed'
                    };
                }
            } catch (error) {
                return {
                    valid: false,
                    error: `Node-RED error: ${error.message}`
                };
            }
        }

        async function checkGenericHealth(moduleName, moduleData) {
            try {
                // Generic validation check
                const response = await fetch(`/api/validate/${moduleName}`);
                const data = await response.json();
                
                if (data.success) {
                    return {
                        valid: true,
                        message: 'Service is accessible'
                    };
                } else {
                    return {
                        valid: false,
                        error: 'Service validation failed'
                    };
                }
            } catch (error) {
                return {
                    valid: false,
                    error: `Service error: ${error.message}`
                };
            }
        }

        function renderHealthResults(results) {
            const container = document.getElementById('healthResults');
            
            if (results.length === 0) {
                container.innerHTML = '<div class="health-item"><div class="health-item-info">No modules found</div></div>';
                return;
            }

            // Module icons mapping
            const moduleIcons = {
                'telegram': '📱',
                'home_assistant': '🏠',
                'openai': '🤖',
                'gemini': '💎',
                'claude': '🎯',
                'nodered': '🔴',
                'whatsapp': '💬'
            };

            const html = results.map(result => {
                const statusClass = result.status;
                let statusText = result.status.charAt(0).toUpperCase() + result.status.slice(1);
                let statusIcon = '';
                
                // Status icons
                switch(result.status) {
                    case 'healthy':
                        statusIcon = '✅';
                        break;
                    case 'warning':
                        statusIcon = '⚠️';
                        break;
                    case 'error':
                        statusIcon = '❌';
                        break;
                    case 'info':
                        statusIcon = 'ℹ️';
                        break;
                    default:
                        statusIcon = '❓';
                }
                
                const moduleIcon = moduleIcons[result.name] || '🔧';
                const moduleName = capitalizeFirst(result.name);
                
                return `
                    <div class="health-item ${statusClass}">
                        <div class="health-item-info">
                            <span style="font-size: 1.5rem;">${moduleIcon}</span>
                            <div>
                                <div><strong>${moduleName}</strong></div>
                                <div style="font-size: 0.875rem; color: var(--gray-600);">${result.message}</div>
                            </div>
                        </div>
                        <div class="health-status ${statusClass}">${statusIcon} ${statusText}</div>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        function startPeriodicHealthCheck() {
            if (healthCheckInterval) {
                showToast('Periodic health check is already running', 'warning');
                return;
            }

            showToast('Starting periodic health check (every 5 minutes)', 'success');
            runHealthCheck(); // Run immediately
            
            healthCheckInterval = setInterval(() => {
                runHealthCheck();
            }, 5 * 60 * 1000); // Every 5 minutes
        }

        function stopPeriodicHealthCheck() {
            if (healthCheckInterval) {
                clearInterval(healthCheckInterval);
                healthCheckInterval = null;
                showToast('Periodic health check stopped', 'info');
            } else {
                showToast('No periodic health check is running', 'warning');
            }
        }

        // Node-RED Management Functions
        function showFlowUpload() {
            document.getElementById('flowUploadModal').style.display = 'block';
            setupFileUpload();
        }

        function closeFlowUpload() {
            document.getElementById('flowUploadModal').style.display = 'none';
            document.getElementById('uploadPreview').style.display = 'none';
            currentFlowData = null;
        }

        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('flowFileInput');

            // Click to select file
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });

            // File input change
            fileInput.addEventListener('change', handleFileSelect);

            // Drag and drop
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        }

        function handleFile(file) {
            if (!file.name.endsWith('.json')) {
                showToast('Please select a JSON file', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const flowData = JSON.parse(e.target.result);
                    currentFlowData = flowData;
                    
                    // Show preview
                    document.getElementById('flowPreview').textContent = JSON.stringify(flowData, null, 2);
                    document.getElementById('uploadPreview').style.display = 'block';
                    
                    showToast('Flow file loaded successfully', 'success');
                } catch (error) {
                    showToast('Invalid JSON file', 'error');
                }
            };
            reader.readAsText(file);
        }

        async function deployFlow() {
            if (!currentFlowData) {
                showToast('No flow data to deploy', 'error');
                return;
            }

            try {
                showToast('Deploying flow...', 'info');
                
                const response = await fetch('/api/nodered/nodered/upload', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        flowData: currentFlowData,
                        filename: 'uploaded_flow.json'
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    showToast('Flow deployed successfully!', 'success');
                    closeFlowUpload();
                    loadNodeRedFlows();
                } else {
                    showToast(`Deployment failed: ${result.error}`, 'error');
                }
            } catch (error) {
                showToast(`Deployment error: ${error.message}`, 'error');
            }
        }

        async function loadNodeRedFlows() {
            try {
                showToast('Loading current flows...', 'info');
                
                const response = await fetch('/api/nodered/nodered/flows');
                const result = await response.json();
                
                if (result.success) {
                    const flows = result.data || [];
                    const flowTabs = flows.filter(f => f.type === 'tab');
                    
                    // Update flow count in info box
                    document.getElementById('noderedFlowCount').textContent = flowTabs.length;
                    
                    // Display flows with details
                    const container = document.getElementById('noderedResults');
                    let flowsHTML = `
                        <div class="health-item healthy">
                            <div class="health-item-info">
                                <span>📋</span>
                                <div>
                                    <div><strong>Current Flows</strong></div>
                                    <div style="font-size: 0.875rem; color: var(--gray-600);">
                                        ${flowTabs.length} flows loaded, ${flows.length} total nodes
                                    </div>
                                </div>
                            </div>
                            <div class="health-status healthy">Loaded</div>
                        </div>
                    `;
                    
                    // List each flow
                    if (flowTabs.length > 0) {
                        flowsHTML += '<div style="margin-top: 1rem; background: white; border-radius: 0.5rem; padding: 1rem;">';
                        flowsHTML += '<h3 style="margin-bottom: 1rem; color: var(--gray-700);">📁 Available Flows:</h3>';
                        flowsHTML += '<div style="display: grid; gap: 0.5rem;">';
                        
                        flowTabs.forEach((flow, index) => {
                            const nodeCount = flows.filter(n => n.z === flow.id).length;
                            const isDisabled = flow.disabled ? '(Disabled)' : '';
                            flowsHTML += `
                                <div style="padding: 0.75rem; background: var(--gray-50); border-radius: 0.375rem; border-left: 3px solid var(--primary-color);">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <div style="flex: 1;">
                                            <strong style="color: var(--gray-800);">${index + 1}. ${flow.label || flow.id}</strong>
                                            ${isDisabled ? '<span style="color: var(--danger-color); margin-left: 0.5rem; font-size: 0.85rem;">⚠️ Disabled</span>' : ''}
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                                            <span style="color: var(--gray-600); font-size: 0.875rem;">${nodeCount} nodes</span>
                                            <button class="btn btn-sm btn-danger" onclick="deleteNodeRedFlow('${flow.id}', '${(flow.label || flow.id).replace(/'/g, "\\'")}')">🗑️ Delete</button>
                                        </div>
                                    </div>
                                    ${flow.info ? `<div style="margin-top: 0.25rem; font-size: 0.875rem; color: var(--gray-600);">${flow.info.substring(0, 100)}${flow.info.length > 100 ? '...' : ''}</div>` : ''}
                                </div>
                            `;
                        });
                        
                        flowsHTML += '</div></div>';
                    }
                    
                    container.innerHTML = flowsHTML;
                    showToast('Flows loaded successfully', 'success');
                } else {
                    showToast(`Failed to load flows: ${result.error}`, 'error');
                }
            } catch (error) {
                showToast(`Error loading flows: ${error.message}`, 'error');
            }
        }

        // Load Node-RED service info
        async function loadNodeRedInfo() {
            try {
                // Get Node-RED credentials to fetch service URL
                const credsResponse = await fetch('/api/credentials/nodered');
                if (credsResponse.ok) {
                    const credsData = await credsResponse.json();
                    const serviceUrl = credsData.data?.base_url || 'Not configured';
                    document.getElementById('noderedServiceUrl').textContent = serviceUrl;
                }
                
                // Load flows to get count
                const flowsResponse = await fetch('/api/nodered/nodered/flows');
                if (flowsResponse.ok) {
                    const flowsData = await flowsResponse.json();
                    if (flowsData.success) {
                        const flows = flowsData.data || [];
                        const flowTabs = flows.filter(f => f.type === 'tab');
                        document.getElementById('noderedFlowCount').textContent = flowTabs.length;
                    }
                }
            } catch (error) {
                console.error('Failed to load Node-RED info:', error);
            }
        }
        
        // Load Node-RED flows for card display
        async function loadNodeRedFlowsForCard() {
            const contentDiv = document.getElementById('nodered-flows-content');
            if (!contentDiv) return;
            
            try {
                contentDiv.innerHTML = '<div style="text-align: center; color: var(--gray-500);">⏳ Loading...</div>';
                
                const response = await fetch('/api/nodered/nodered/flows');
                const result = await response.json();
                
                if (result.success) {
                    const flows = result.data || [];
                    const flowTabs = flows.filter(f => f.type === 'tab' && !f.disabled);
                    
                    if (flowTabs.length === 0) {
                        contentDiv.innerHTML = '<div style="color: var(--gray-500); text-align: center;">No active flows found</div>';
                        return;
                    }
                    
                    let html = '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';
                    flowTabs.forEach((flow, index) => {
                        const nodeCount = flows.filter(n => n.z === flow.id).length;
                        html += `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: white; border-radius: 0.375rem; border-left: 3px solid var(--primary-color);">
                                <div style="flex: 1;">
                                    <strong style="color: var(--gray-800); font-size: 0.95rem;">${flow.label || flow.id}</strong>
                                </div>
                                <div style="display: flex; align-items: center; gap: 0.75rem;">
                                    <span style="color: var(--gray-600); font-size: 0.85rem; white-space: nowrap;">${nodeCount} nodes</span>
                                    <button class="btn btn-sm btn-danger" onclick="deleteNodeRedFlow('${flow.id}', '${(flow.label || flow.id).replace(/'/g, "\\'")}')">🗑️ Delete</button>
                                </div>
                            </div>
                        `;
                    });
                    html += '</div>';
                    html += `<div style="margin-top: 0.75rem; text-align: center; color: var(--gray-600); font-size: 0.85rem;">Total: ${flowTabs.length} flows</div>`;
                    
                    contentDiv.innerHTML = html;
                } else {
                    contentDiv.innerHTML = '<div style="color: var(--danger-color); text-align: center;">⚠️ ' + (result.error || 'Failed to load flows') + '</div>';
                }
            } catch (error) {
                console.error('Failed to load Node-RED flows:', error);
                contentDiv.innerHTML = '<div style="color: var(--danger-color); text-align: center;">❌ Error loading flows</div>';
            }
        }
        
        // Delete a Node-RED flow
        async function deleteNodeRedFlow(flowId, flowLabel) {
            if (!confirm(`Are you sure you want to delete flow "${flowLabel}"?\n\nThis action cannot be undone.`)) {
                return;
            }
            
            try {
                showToast('Deleting flow...', 'info');
                
                // First, get all current flows
                const getResponse = await fetch('/api/nodered/nodered/flows');
                const getResult = await getResponse.json();
                
                if (!getResult.success) {
                    throw new Error(getResult.error || 'Failed to get current flows');
                }
                
                const allFlows = getResult.data || [];
                
                // Filter out the flow tab and all its nodes
                const updatedFlows = allFlows.filter(node => {
                    // Remove the flow tab itself
                    if (node.id === flowId) return false;
                    // Remove all nodes that belong to this flow
                    if (node.z === flowId) return false;
                    return true;
                });
                
                // Deploy the updated flows
                const deployResponse = await fetch('/api/nodered/nodered/flows', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ flows: updatedFlows })
                });
                
                const deployResult = await deployResponse.json();
                
                if (deployResult.success) {
                    showToast(`Flow "${flowLabel}" deleted successfully`, 'success');
                    // Refresh the flow list
                    loadNodeRedFlowsForCard();
                    // Also refresh the main Node-RED section if visible
                    const noderedResults = document.getElementById('noderedResults');
                    if (noderedResults && noderedResults.innerHTML.trim() !== '') {
                        loadNodeRedFlows();
                    }
                } else {
                    throw new Error(deployResult.error || 'Failed to deploy updated flows');
                }
            } catch (error) {
                console.error('Failed to delete flow:', error);
                showToast(`Failed to delete flow: ${error.message}`, 'error');
            }
        }
        
        // Open Node-RED service in new tab
        function openNodeRedService() {
            const serviceUrl = document.getElementById('noderedServiceUrl').textContent;
            if (serviceUrl && serviceUrl !== 'Loading...' && serviceUrl !== 'Not configured') {
                window.open(serviceUrl, '_blank');
            } else {
                showToast('Node-RED service URL not configured', 'warning');
            }
        }

        async function validateCurrentFlows() {
            try {
                showToast('Validating flows...', 'info');
                
                const response = await fetch('/api/nodered/nodered/validate');
                const result = await response.json();
                
                if (result.success) {
                    const container = document.getElementById('noderedResults');
                    container.innerHTML = `
                        <div class="health-item healthy">
                            <div class="health-item-info">
                                <span>✅</span>
                                <div>
                                    <div><strong>Flow Validation</strong></div>
                                    <div style="font-size: 0.875rem; color: var(--gray-600);">
                                        ${result.data.node_count} nodes validated
                                    </div>
                                </div>
                            </div>
                            <div class="health-status healthy">Valid</div>
                        </div>
                    `;
                    showToast('Flows validation passed', 'success');
                } else {
                    showToast(`Validation failed: ${result.error}`, 'error');
                }
            } catch (error) {
                showToast(`Validation error: ${error.message}`, 'error');
            }
        }

        function showBackupManager() {
            document.getElementById('backupModal').style.display = 'block';
            refreshBackups();
        }

        function closeBackupManager() {
            document.getElementById('backupModal').style.display = 'none';
        }

        async function refreshBackups() {
            try {
                const response = await fetch('/api/nodered/nodered/backups');
                const result = await response.json();
                
                if (result.success) {
                    renderBackupList(result.data);
                } else {
                    showToast(`Failed to load backups: ${result.error}`, 'error');
                }
            } catch (error) {
                showToast(`Error loading backups: ${error.message}`, 'error');
            }
        }

        function renderBackupList(backups) {
            const container = document.getElementById('backupList');
            
            if (backups.length === 0) {
                container.innerHTML = '<p>No backups found</p>';
                return;
            }

            const html = backups.map(backup => `
                <div class="backup-item">
                    <div class="backup-info">
                        <h4>Backup ${backup.id}</h4>
                        <p>Created: ${new Date(backup.timestamp).toLocaleString()}</p>
                        <p>Flows: ${backup.flow_count}</p>
                    </div>
                    <div class="backup-actions">
                        <button class="btn btn-primary" onclick="restoreBackup('${backup.id}')">🔄 Restore</button>
                        <button class="btn btn-danger" onclick="deleteBackup('${backup.id}')">🗑️ Delete</button>
                    </div>
                </div>
            `).join('');

            container.innerHTML = html;
        }

        async function createBackup() {
            try {
                showToast('Creating backup...', 'info');
                
                const response = await fetch('/api/nodered/nodered/backup', {
                    method: 'POST'
                });
                const result = await response.json();
                
                if (result.success) {
                    showToast('Backup created successfully', 'success');
                    refreshBackups();
                } else {
                    showToast(`Backup failed: ${result.error}`, 'error');
                }
            } catch (error) {
                showToast(`Backup error: ${error.message}`, 'error');
            }
        }

        async function restoreBackup(backupId) {
            if (!confirm('Are you sure you want to restore this backup? This will replace your current flows.')) {
                return;
            }

            try {
                showToast('Restoring backup...', 'info');
                
                const response = await fetch(`/api/nodered/nodered/restore/${backupId}`, {
                    method: 'POST'
                });
                const result = await response.json();
                
                if (result.success) {
                    showToast('Backup restored successfully', 'success');
                    loadNodeRedFlows();
                } else {
                    showToast(`Restore failed: ${result.error}`, 'error');
                }
            } catch (error) {
                showToast(`Restore error: ${error.message}`, 'error');
            }
        }

        async function deleteBackup(backupId) {
            if (!confirm('Are you sure you want to delete this backup?')) {
                return;
            }

            try {
                showToast('Deleting backup...', 'info');
                
                const response = await fetch(`/api/nodered/nodered/backup/${backupId}`, {
                    method: 'DELETE'
                });
                const result = await response.json();
                
                if (result.success) {
                    showToast('Backup deleted successfully', 'success');
                    refreshBackups();
                } else {
                    showToast(`Delete failed: ${result.error}`, 'error');
                }
            } catch (error) {
                showToast(`Delete error: ${error.message}`, 'error');
            }
        }
    </script>
</body>
</html>
